{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code/","title":"Modules","text":""},{"location":"code/#overview","title":"Overview","text":"<p>These are the modules used in this package:</p> Module Description Time Series The <code>time_series</code> module provides a class for generating synthetic time series data. It includes methods for creating time series with various characteristics, such as seasonality, trends, and noise."},{"location":"code/#testing","title":"Testing","text":"<p>This package is fully tested against:</p> <ol> <li>Unit tests</li> <li>Lint tests</li> <li>MyPy tests</li> <li>Build tests</li> </ol> <p>Tests are run in matrix against:</p> <ol> <li>Python Versions:<ol> <li><code>3.9</code></li> <li><code>3.10</code></li> <li><code>3.11</code></li> <li><code>3.12</code></li> <li><code>3.13</code></li> </ol> </li> <li>Operating Systems:<ol> <li><code>ubuntu-latest</code></li> <li><code>windows-latest</code></li> <li><code>macos-latest</code></li> </ol> </li> </ol>"},{"location":"code/#coverage","title":"Coverage","text":""},{"location":"code/time_series/","title":"Time Series","text":""},{"location":"code/time_series/#synthetic_data_generators.time_series","title":"synthetic_data_generators.time_series","text":"<p>Summary</p> <p>The <code>time_series</code> module provides a class for generating synthetic time series data. It includes methods for creating time series with various characteristics, such as seasonality, trends, and noise.</p>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator","title":"TimeSeriesGenerator","text":"<p>Summary</p> <p>A class for generating synthetic time series data.</p> Details <ul> <li>This class provides methods to create synthetic time series data with various characteristics, including seasonality, trends, and noise.</li> <li>The generated data can be used for testing and validation purposes in time series analysis.</li> <li>The class includes methods to generate holiday indices, fixed error indices, semi-Markov indices, and sine indices.</li> <li>It also provides a method to generate polynomial trends and ARMA components.</li> <li>The generated time series data can be customized with different parameters, such as start date, number of periods, and noise scale.</li> </ul> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>class TimeSeriesGenerator:\n    \"\"\"\n    !!! note \"Summary\"\n        A class for generating synthetic time series data.\n\n    ???+ info \"Details\"\n        - This class provides methods to create synthetic time series data with various characteristics, including seasonality, trends, and noise.\n        - The generated data can be used for testing and validation purposes in time series analysis.\n        - The class includes methods to generate holiday indices, fixed error indices, semi-Markov indices, and sine indices.\n        - It also provides a method to generate polynomial trends and ARMA components.\n        - The generated time series data can be customized with different parameters, such as start date, number of periods, and noise scale.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Initialize the TimeSeriesGenerator class.\n\n        ???+ info \"Details\"\n            - This class is designed to generate synthetic time series data for testing and validation purposes.\n            - It provides methods to create time series data with various characteristics, including seasonality, trends, and noise.\n            - The generated data can be used for testing algorithms, models, and other applications in time series analysis.\n            - The class includes methods for generating holiday indices, fixed error indices, semi-Markov indices, and sine indices.\n            - It also provides a method for generating polynomial trends and ARMA components.\n            - The generated time series data can be customized with different parameters, such as start date, number of periods, and noise scale.\n            - The class is designed to be flexible and extensible, allowing users to easily modify the generation process to suit their needs.\n            - It is built using Python's type hinting and type checking features to ensure that the inputs and outputs are of the expected types.\n            - This helps to catch potential errors early in the development process and improve code readability.\n        \"\"\"\n        pass\n\n    def _random_generator(self, seed: int | None = None) -&gt; RandomGenerator:\n        \"\"\"\n        !!! note \"Summary\"\n            Get the random number generator.\n\n        Returns:\n            (RandomGenerator):\n                The random number generator instance.\n        \"\"\"\n        return np.random.default_rng(seed=seed)\n\n    @staticmethod\n    @lru_cache\n    def _generate_dates(start_date: datetime, end_date: datetime) -&gt; datetime_list:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a list of dates between a start and end date.\n\n        Params:\n            start_date (datetime):\n                The starting date for generating dates.\n            end_date (datetime):\n                The ending date for generating dates.\n\n        Returns:\n            (datetime_list):\n                A list of datetime objects representing the generated dates.\n        \"\"\"\n        return pd.date_range(start_date, end_date).to_pydatetime().tolist()\n\n    @staticmethod\n    def _generate_holiday_period(start_date: datetime, periods: int) -&gt; datetime_list:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a list of holiday dates starting from a given date.\n\n        Params:\n            start_date (datetime):\n                The starting date for generating holiday dates.\n            periods (int):\n                The number of holiday dates to generate.\n\n        Returns:\n            (datetime_list):\n                A list of datetime objects representing the generated holiday dates.\n        \"\"\"\n        return pd.date_range(start_date, periods=periods).to_pydatetime().tolist()\n\n    def create_time_series(\n        self,\n        start_date: datetime = datetime(2019, 1, 1),\n        n_periods: int = 1096,\n        interpolation_nodes: tuple[int_list_tuple, ...] | list[int_list_tuple] = (\n            [0, 98],\n            [300, 92],\n            [700, 190],\n            [1096, 213],\n        ),\n        level_breaks: tuple[int_list_tuple, ...] | list[int_list_tuple] | None = (\n            [250, 100],\n            [650, -50],\n        ),\n        AR: list[float] | None = None,\n        MA: list[float] | None = None,\n        randomwalk_scale: float = 2,\n        exogenous: list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None = None,\n        season_conf: dict_str_any | None = {\"style\": \"holiday\"},\n        season_eff: float = 0.15,\n        manual_outliers: tuple[int_list_tuple, ...] | list[int_list_tuple] | None = None,\n        noise_scale: float = 10,\n        seed: int | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a synthetic time series with specified characteristics.\n\n        ???+ info \"Details\"\n            - The function generates a time series based on the specified parameters, including start date, number of periods, interpolation nodes, level breaks, ARMA coefficients, random walk scale, exogenous variables, seasonality configuration, manual outliers, and noise scale.\n            - The generated time series is returned as a pandas DataFrame with two columns: \"Date\" and \"Value\".\n            - The \"Date\" column contains the dates of the time series, and the \"Value\" column contains the corresponding values.\n            - The function also includes options for generating seasonality indices, fixed error indices, semi-Markov indices, and sine indices.\n            - The generated time series can be customized with different parameters, such as start date, number of periods, and noise scale.\n\n        !!! warning \"Important\"\n            This function is designed to generate synthetic time series data for testing and validation purposes.\n            It is not intended to be used for production or real-world applications.\n\n        Params:\n            start_date (datetime):\n                The starting date for the time series.&lt;br&gt;\n                Default is `datetime(2019, 1, 1)`.\n            n_periods (int):\n                The number of periods for the time series.&lt;br&gt;\n                Default is `1096`.\n            interpolation_nodes (tuple[int_list_tuple, ...] | list[int_list_tuple]):\n                A collection of interpolation nodes, where each node is a tuple containing the x-coordinate and y-coordinate.&lt;br&gt;\n                The x-coordinates should be in ascending order.&lt;br&gt;\n                Default is `([0, 98], [300, 92], [700, 190], [1096, 213])`.\n            level_breaks (tuple[int_list_tuple, ...] | list[int_list_tuple] | None):\n                A collection of level breaks, where each break is a tuple containing the index and the value to add.&lt;br&gt;\n                Default is `([250, 100], [650, -50])`.\n            AR (list[float] | None):\n                The autoregressive coefficients for the ARMA model.&lt;br&gt;\n                Default is `None`.\n            MA (list[float] | None):\n                The moving average coefficients for the ARMA model.&lt;br&gt;\n                Default is `None`.\n            randomwalk_scale (float):\n                The scale of the random walk component.&lt;br&gt;\n                Default is `2`.\n            exogenous (list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None):\n                A list of exogenous variables to include in the ARMA model.&lt;br&gt;\n                Default is `None`.\n            season_conf (dict_str_any | None):\n                A dictionary containing the configuration for seasonality.&lt;br&gt;\n                Default is `{\"style\": \"holiday\"}`.\n            season_eff (float):\n                The effectiveness of the seasonality component.&lt;br&gt;\n                Default is `0.15`.\n            manual_outliers (tuple[int_list_tuple, ...] | list[int_list_tuple] | None):\n                A collection of manual outliers, where each outlier is a tuple containing the index and the value to set.&lt;br&gt;\n                Default is `None`.\n            noise_scale (float):\n                The scale of the noise component.&lt;br&gt;\n                Default is `10`.\n            seed (int | None):\n                The random seed for reproducibility.&lt;br&gt;\n                Default is `None`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n            (AssertionError):\n                If `interpolation_nodes` does not contain exactly two elements.\n            (TypeError):\n                If the first element of `interpolation_nodes` is not a `datetime`, or the second element is not an `int`.\n\n        Returns:\n            (pd.DataFrame):\n                A pandas DataFrame containing the generated time series data.\n                The DataFrame has two columns: \"Date\" and \"Value\".\n                The \"Date\" column contains the dates of the time series, and the \"Value\" column contains the corresponding values.\n        \"\"\"\n\n        # Validations\n        AR = AR or [1]\n        MA = MA or [0]\n        exogenous = exogenous or []\n        manual_outliers = manual_outliers or []\n        assert AR is not None\n        assert MA is not None\n        assert manual_outliers is not None\n\n        # Date index:\n        dates: datetime_list = pd.date_range(start_date, periods=n_periods).to_pydatetime().tolist()\n\n        # Cubic trend component:\n        trend: NDArray[np.float64] = self.generate_polynom_trend(interpolation_nodes, n_periods)\n\n        # Structural break:\n        break_effect: NDArray[np.float64] = np.zeros(n_periods).astype(np.float64)\n        if level_breaks:\n            for level_break in level_breaks:\n                break_effect[level_break[0] :] += level_break[1]\n\n        # ARMA(AR,MA) component:\n        randomwalk: NDArray[np.float64] = self.generate_ARMA(\n            AR=AR,\n            MA=MA,\n            randomwalk_scale=randomwalk_scale,\n            n_periods=n_periods,\n            exogenous=exogenous,\n            seed=seed,\n        )\n\n        # Season:\n        if season_conf is not None:\n            season: NDArray[np.float64] = self.generate_season_index(dates=dates, **season_conf)  # type: ignore\n            season = season * season_eff + (1 - season)\n        else:\n            season = np.ones(n_periods)\n\n        # Noise component on top:\n        noise: NDArray[np.float64] = self._random_generator(seed=seed).normal(\n            loc=0.0,\n            scale=noise_scale,\n            size=n_periods,\n        )\n\n        # Assemble finally:\n        df: pd.DataFrame = pd.DataFrame(\n            list(\n                zip(\n                    dates,\n                    (trend + break_effect + randomwalk + noise) * season,\n                )\n            ),\n            index=dates,\n            columns=[\"Date\", \"Value\"],\n        )\n\n        # Manual outliers:\n        if manual_outliers:\n            for manual_outlier in manual_outliers:\n                df.iloc[manual_outlier[0], 1] = manual_outlier[1]\n\n        return df\n\n    @typechecked\n    def generate_holiday_index(\n        self,\n        dates: datetime_list_tuple,\n        season_dates: Collection_of_Collection_of_datetime_or_int,\n    ) -&gt; NDArray[np.int_]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a holiday index for the given dates based on the provided holiday dates.\n\n        ???+ info \"Details\"\n            - A holiday index is a manual selection for date in `dates` to determine whether it is a holiday or not.\n            - Basically, it is a manual index of dates in a univariate time series data set which are actual holidays.\n            - The return array is generated by checking if each date in `dates` is present in the list of holiday dates generated from `season_dates`.\n\n        !!! warning \"Important\"\n            This function is designed to work with a `.generate_season_index()` when the `style=\"holiday\"`.&lt;br&gt;\n            It is not intended to be called directly.\n\n        Params:\n            dates (datetime_list_tuple):\n                List of datetime objects representing the dates to check.\n            season_dates (Collection_of_Collection_of_datetime_or_int):\n                Collection of collections containing holiday dates and their respective periods.&lt;br&gt;\n                Each element in the collection should contain exactly two elements: a datetime object and an integer representing the number of periods.&lt;br&gt;\n                Some example inputs include:\\n\n                - List of lists containing datetime and periods: `season_dates = [[datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4]]`\n                - List of tuples containing datetime and periods: `season_dates = [(datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4)]`\n                - Tuple of lists containing datetime and periods: `season_dates = ([datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4])`\n                - Tuple of tuples containing datetime and periods: `season_dates = ((datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4))`\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n            (AssertionError):\n                If `season_dates` does not contain exactly two elements.\n            (TypeError):\n                If the first element of `season_dates` is not a `datetime`, or the second element is not an `int`.\n\n        Returns:\n            (NDArray[np.int_]):\n                An array of the same length as `dates`, where each element is `1` if the corresponding date is a holiday, and `0` otherwise.\n        \"\"\"\n\n        # Validations\n        assert all(len(elem) == 2 for elem in season_dates)\n        assert_all_values_of_type([season_date[0] for season_date in season_dates], datetime)\n        assert_all_values_of_type([season_date[1] for season_date in season_dates], int)\n\n        # Build dates\n        season_dates_list: list[datetime] = []\n        for _dates in season_dates:\n            season_dates_list.extend(\n                self._generate_holiday_period(\n                    start_date=_dates[0],  # type: ignore\n                    periods=_dates[1],  # type: ignore\n                )\n            )\n\n        # Tag dates\n        events: NDArray[np.int_] = np.where([_date in season_dates_list for _date in dates], 1, 0)\n\n        # Return\n        return events\n\n    @typechecked\n    def generate_fixed_error_index(\n        self,\n        dates: datetime_list_tuple,\n        period_length: int = 7,\n        period_sd: float = 0.5,\n        start_index: int = 4,\n        seed: int | None = None,\n        verbose: bool = False,\n    ) -&gt; NDArray[np.int_]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a fixed error seasonality index for the given dates.\n\n        ???+ info \"Details\"\n            - A holiday index is a manual selection for date in `dates` to determine whether it is a holiday or not.\n            - A fixed error seasonality index is a non-uniform distribution of dates in a univariate time series data set.\n            - Basically, it is indicating every `period_length` length of days, occurring every `period_sd` number of days, starting from `start_index`.\n            - The return array is a boolean `1` or `0` of length `n_periods`. It will have a seasonality of `period_length` and a disturbance standard deviation of `period_sd`. The result can be used as a non-uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).\n\n        !!! warning \"Important\"\n            This function is designed to work with a `.generate_season_index()` when the `style=\"fixed+error\"`.&lt;br&gt;\n            It is not intended to be called directly.\n\n        Params:\n            dates (datetime_list_tuple):\n                List of datetime objects representing the dates to check.\n            period_length (int):\n                The length of the period for seasonality.&lt;br&gt;\n                For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n                Default is `7`.\n            period_sd (float):\n                The standard deviation of the disturbance.&lt;br&gt;\n                Default is `0.5`.\n            start_index (int):\n                The starting index for the seasonality.&lt;br&gt;\n                Default is `4`.\n            verbose (bool):\n                If `True`, print additional information about the generated indices. Helpful for debugging.&lt;br&gt;\n                Default is `False`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n        Returns:\n            (NDArray[np.int_]):\n                An array of the same length as `dates`, where each element is `1` if the corresponding date is a holiday, and `0` otherwise.\n        \"\"\"\n\n        # Process\n        n_periods: int = len(dates)\n        events: NDArray[np.int_] = np.zeros(n_periods).astype(np.int_)\n        event_inds: NDArray[Any] = np.arange(n_periods // period_length + 1) * period_length + start_index\n        disturbance: NDArray[np.int_] = (\n            self._random_generator(seed=seed)\n            .normal(\n                loc=0.0,\n                scale=period_sd,\n                size=len(event_inds),\n            )\n            .round()\n            .astype(int)\n        )\n        event_inds = event_inds + disturbance\n\n        # Delete indices that are out of bounds\n        if np.any(event_inds &gt;= n_periods):\n            event_inds = np.delete(event_inds, event_inds &gt;= n_periods)\n\n        # For any indices defined above, assign `1` to the events array\n        events[event_inds] = 1\n\n        # Check debugging\n        if verbose:\n            print(f\"Disturbance: {disturbance}\")\n            print(f\"Event indices: {event_inds}\")\n            print(f\"Weekdays: {np.mod(event_inds, period_length)}\")\n            print(f\"Histogram: {np.histogram(np.mod(event_inds, period_length), bins=np.arange(period_length))}\")\n\n        # Return\n        return events.astype(np.int_)\n\n    def generate_semi_markov_index(\n        self,\n        dates: datetime_list_tuple,\n        period_length: int = 7,\n        period_sd: float = 0.5,\n        start_index: int = 4,\n        seed: int | None = None,\n        verbose: bool = False,\n    ) -&gt; NDArray[np.int_]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a semi-Markov seasonality index for the given dates.\n\n        ???+ info \"Details\"\n            - A semi-Markov seasonality index is a uniform distribution of dates in a univariate time series data set.\n            - Basically, it is indicating a `period_length` length of days, occurring randomly roughly ever `period_sd` number of days, starting from `start_index`.\n            - The return array is a boolean `1` or `0` of length `n_periods`. It will have a seasonality of `period_length` and a disturbance standard deviation of `period_sd`. The result can be used as a uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).\n\n        Params:\n            dates (datetime_list_tuple):\n                List of datetime objects representing the dates to check.\n            period_length (int):\n                The length of the period for seasonality.&lt;br&gt;\n                For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n                Default is `7`.\n            period_sd (float):\n                The standard deviation of the disturbance.&lt;br&gt;\n                Default is `0.5`.\n            start_index (int):\n                The starting index for the seasonality.&lt;br&gt;\n                Default is `4`.\n            verbose (bool):\n                If `True`, print additional information about the generated indices. Helpful for debugging.&lt;br&gt;\n                Default is `False`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n        Returns:\n            (NDArray[np.int_]):\n                An array of the same length as `dates`, where each element is `1` if the corresponding date is a holiday, and `0` otherwise.\n        \"\"\"\n\n        # Process\n        n_periods: int = len(dates)\n        events: NDArray[np.int_] = np.zeros(n_periods).astype(np.int_)\n        event_inds: list[int] = [start_index]\n        new = np.random.normal(loc=period_length, scale=period_sd, size=1).round()[0]\n        while new + event_inds[-1] &lt; n_periods:\n            event_inds.append(new + event_inds[-1])\n            new = (\n                self._random_generator(seed=seed)\n                .normal(\n                    loc=period_length,\n                    scale=period_sd,\n                    size=1,\n                )\n                .round()[0]\n            )\n        event_indexes: NDArray[np.int_] = np.array(event_inds).astype(np.int_)\n\n        # For any indices defined above, assign `1` to the events array\n        events[event_indexes] = 1\n\n        # Check debugging\n        if verbose:\n            print(f\"Event indices: {event_inds}\")\n            print(f\"Weekdays: {np.mod(event_inds, period_length)}\")\n            print(f\"Histogram: {np.histogram(np.mod(event_inds, period_length), bins=np.arange(period_length))}\")\n\n        # Return\n        return events\n\n    def generate_sin_index(\n        self,\n        dates: datetime_list_tuple,\n        period_length: int = 7,\n        start_index: int = 4,\n    ) -&gt; NDArray[np.float64]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a sine seasonality index for the given dates.\n\n        ???+ info \"Details\"\n            - A sine seasonality index is a periodic function that oscillates between `0` and `1`.\n            - It is used to model seasonal patterns in time series data.\n            - The return array is a sine wave of length `n_periods`, with a period of `period_length` and a phase shift of `start_index`.\n            - The result can be used to represent seasonal patterns in time series data, such as daily or weekly cycles.\n\n        Params:\n            dates (datetime_list_tuple):\n                List of datetime objects representing the dates to check.\n            period_length (int):\n                The length of the period for seasonality.&lt;br&gt;\n                For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n                Default is `7`.\n            start_index (int):\n                The starting index for the seasonality. Designed to account for seasonal patterns that start at a different point in time.&lt;br&gt;\n                Default is `4`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n        Returns:\n            (NDArray[np.float64]):\n                An array of the same length as `dates`, where each element is a sine value representing the seasonal pattern.\n        \"\"\"\n        n_periods: int = len(dates)\n        events = (np.sin((np.arange(n_periods) - start_index) / period_length * 2 * np.pi) + 1) / 2\n        return events\n\n    def generate_sin_covar_index(\n        self,\n        dates: datetime_list_tuple,\n        period_length: int = 7,\n        start_index: int = 4,\n    ) -&gt; NDArray[np.float64]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a sine seasonality index with covariance for the given dates.\n\n        ???+ info \"Details\"\n            - A sine seasonality index with covariance is a periodic function that oscillates between `0` and `1`.\n            - It is used to model seasonal patterns in time series data, taking into account the covariance structure of the data.\n            - The return array is a sine wave of length `n_periods`, with a period of `period_length` and a phase shift of `start_index`.\n            - The result can be used to represent seasonal patterns in time series data, such as daily or weekly cycles.\n\n        Params:\n            dates (datetime_list_tuple):\n                List of datetime objects representing the dates to check.\n            period_length (int):\n                The length of the period for seasonality.&lt;br&gt;\n                For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n                Default is `7`.\n            start_index (int):\n                The starting index for the seasonality. Designed to account for seasonal patterns that start at a different point in time.&lt;br&gt;\n                Default is `4`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n        Returns:\n            (NDArray[np.float64]):\n                An array of the same length as `dates`, where each element is a sine value representing the seasonal pattern.\n        \"\"\"\n        n_periods: int = len(dates)\n        covar_wave = (np.sin((np.arange(n_periods) - start_index) / period_length / 6 * np.pi) + 2) / 2\n        dx: NDArray[np.float64] = np.full_like(covar_wave, 0.4)\n        sin_wave: NDArray[np.float64] = np.sin((covar_wave * dx).cumsum())\n        return sin_wave\n\n    def generate_season_index(\n        self,\n        dates: datetime_list_tuple,\n        style: Literal[\n            \"fixed+error\",\n            \"semi-markov\",\n            \"holiday\",\n            \"sin\",\n            \"sin_covar\",\n        ],\n        season_dates: Collection_of_Collection_of_datetime_or_int | None = None,\n        period_length: int | None = None,\n        period_sd: float | None = None,\n        start_index: int | None = None,\n        seed: int | None = None,\n        verbose: bool = False,\n    ) -&gt; NDArray[np.float64]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a seasonality index for the given dates based on the specified style.\n\n        ???+ info \"Details\"\n            - A seasonality index is a manual selection for date in `dates` to determine whether it is a holiday or not.\n            - Basically, it is a manual index of dates in a univariate time series data set which are actual holidays.\n            - The return array is generated by checking if each date in `dates` is present in the list of holiday dates generated from `season_dates`.\n            - The return array is a boolean `1` or `0` of length `n_periods`. It will have a seasonality of `period_length` and a disturbance standard deviation of `period_sd`. The result can be used as a non-uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).\n\n        Params:\n            dates (datetime_list_tuple):\n                List of datetime objects representing the dates to check.\n            style (Literal):\n                The style of the seasonality index to generate.&lt;br&gt;\n                Possible values are:\n                - `\"fixed+error\"`: Fixed error seasonality index.\n                - `\"semi-markov\"`: Semi-Markov seasonality index.\n                - `\"holiday\"`: Holiday seasonality index.\n                - `\"sin\"`: Sine seasonality index.\n                - `\"sin_covar\"`: Sine seasonality index with covariance.\n            season_dates (Collection_of_Collection_of_datetime_or_int | None):\n                Collection of collections containing holiday dates and their respective periods.&lt;br&gt;\n                Each element in the collection should contain exactly two elements: a datetime object and an integer representing the number of periods.&lt;br&gt;\n                Some example inputs include:\\n\n                - List of lists containing datetime and periods: `season_dates = [[datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4]]`\n                - List of tuples containing datetime and periods: `season_dates = [(datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4)]`\n                - Tuple of lists containing datetime and periods: `season_dates = ([datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4])`\n                - Tuple of tuples containing datetime and periods: `season_dates = ((datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4))`\n            period_length (int | None):\n                The length of the period for seasonality.&lt;br&gt;\n                For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n                Default is `7`.\n            period_sd (float | None):\n                The standard deviation of the disturbance.&lt;br&gt;\n                Default is `0.5`.\n            start_index (int | None):\n                The starting index for the seasonality.&lt;br&gt;\n                Default is `4`.\n            seed (int | None):\n                Random seed for reproducibility.&lt;br&gt;\n                Default is `None`.\n            verbose (bool):\n                If `True`, print additional information about the generated indices. Helpful for debugging.&lt;br&gt;\n                Default is `False`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n            (AssertionError):\n                If `season_dates` does not contain exactly two elements.\n            (TypeError):\n                If the first element of `season_dates` is not a `datetime`, or the second element is not an `int`.\n            (ValueError):\n                If `style` is not one of the supported styles.\n                If `period_length`, `period_sd`, or `start_index` are not provided for the corresponding styles.\n\n        Returns:\n            (NDArray[np.float64]):\n                An array of the same length as `dates`, where each element is a sine value representing the seasonal pattern.\n        \"\"\"\n        if \"fixed\" in style and \"error\" in style:\n            assert period_length is not None\n            assert period_sd is not None\n            assert start_index is not None\n            return self.generate_fixed_error_index(\n                dates=dates,\n                period_length=period_length,\n                period_sd=period_sd,\n                start_index=start_index,\n                seed=seed,\n                verbose=verbose,\n            ).astype(np.float64)\n        elif \"semi\" in style and \"markov\" in style:\n            assert period_length is not None\n            assert period_sd is not None\n            assert start_index is not None\n            return self.generate_semi_markov_index(\n                dates=dates,\n                period_length=period_length,\n                period_sd=period_sd,\n                start_index=start_index,\n                seed=seed,\n                verbose=verbose,\n            ).astype(np.float64)\n        elif style == \"holiday\":\n            assert season_dates is not None\n            return self.generate_holiday_index(dates=dates, season_dates=season_dates).astype(np.float64)\n        elif \"sin\" in style and \"covar\" in style:\n            assert period_length is not None\n            assert start_index is not None\n            return self.generate_sin_covar_index(dates=dates, period_length=period_length).astype(np.float64)\n        elif style == \"sin\":\n            assert period_length is not None\n            assert start_index is not None\n            return self.generate_sin_index(dates=dates, period_length=period_length).astype(np.float64)\n        else:\n            return np.zeros(len(dates)).astype(np.float64)\n\n    def generate_polynom_trend(self, interpol_nodes, n_periods: int) -&gt; NDArray[np.float64]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate a polynomial trend based on the provided interpolation nodes.\n\n        ???+ info \"Details\"\n            - The polynomial trend is generated using the provided interpolation nodes.\n            - The function supports polynomial trends of order 1 (linear), 2 (quadratic), 3 (cubic), and 4 (quartic).\n            - The generated trend is an array of the same length as `n_periods`, where each element represents the value of the polynomial trend at that period.\n            - The function uses numpy's linear algebra solver to compute the coefficients of the polynomial based on the provided interpolation nodes.\n\n        !!! warning \"Important\"\n            This function is implemented only up to order 3 (cubic interpolation = four nodes).\n            It is not intended to be used for higher-order polynomial trends.\n\n        Params:\n            interpol_nodes (tuple[int_list_tuple, ...] | list[int_list_tuple]):\n                A collection of interpolation nodes, where each node is a tuple containing the x-coordinate and y-coordinate.\n                The x-coordinates should be in ascending order.\n            n_periods (int):\n                The number of periods for which to generate the polynomial trend.\n                This determines the length of the output array.\n                The generated trend will have the same length as `n_periods`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n            (AssertionError):\n                If `interpol_nodes` does not contain exactly two elements.\n            (TypeError):\n                If the first element of `interpol_nodes` is not a `datetime`, or the second element is not an `int`.\n\n        Returns:\n            (NDArray[np.float64]):\n                An array of the same length as `n_periods`, where each element represents the value of the polynomial trend at that period.\n        \"\"\"\n\n        if len(interpol_nodes) == 0:\n            # No trend component:\n            trend: NDArray[np.float64] = np.zeros(n_periods)\n            return trend\n\n        elif len(interpol_nodes) == 1:\n            # No trend component:\n            trend: NDArray[np.float64] = np.zeros(n_periods) + interpol_nodes[0][1]\n            return trend\n\n        elif len(interpol_nodes) == 2:\n            # Linear trend component:\n            x1, y1 = interpol_nodes[0]\n            x2, y2 = interpol_nodes[1]\n            M = np.column_stack((np.array([x1, x2]), np.ones(2)))\n            b = np.array([y1, y2])\n            pvec = np.linalg.solve(M, b)\n            trend: NDArray[np.float64] = np.arange(n_periods).astype(np.float64)\n            trend = pvec[0] * trend + pvec[1]\n            return trend\n\n        elif len(interpol_nodes) == 3:\n            # Quadratic trend component:\n            x1, y1 = interpol_nodes[0]\n            x2, y2 = interpol_nodes[1]\n            x3, y3 = interpol_nodes[2]\n            M = np.column_stack(\n                (\n                    np.array([x1, x2, x3]) * np.array([x1, x2, x3]),\n                    np.array([x1, x2, x3]),\n                    np.ones(3),\n                )\n            )\n            b = np.array([y1, y2, y3])\n            pvec = np.linalg.solve(M, b)\n            trend: NDArray[np.float64] = np.arange(n_periods).astype(np.float64)\n            trend = pvec[0] * trend * trend + pvec[1] * trend + pvec[2]\n            return trend\n\n        elif len(interpol_nodes) == 4:\n            # Cubic trend component:\n            x1, y1 = interpol_nodes[0]\n            x2, y2 = interpol_nodes[1]\n            x3, y3 = interpol_nodes[2]\n            x4, y4 = interpol_nodes[3]\n            M = np.column_stack(\n                (\n                    np.array([x1, x2, x3, x4]) * np.array([x1, x2, x3, x4]) * np.array([x1, x2, x3, x4]),\n                    np.array([x1, x2, x3, x4]) * np.array([x1, x2, x3, x4]),\n                    np.array([x1, x2, x3, x4]),\n                    np.ones(4),\n                )\n            )\n            b = np.array([y1, y2, y3, y4])\n            pvec = np.linalg.solve(M, b)\n            trend: NDArray[np.float64] = np.arange(n_periods).astype(np.float64)\n            trend = pvec[0] * trend * trend * trend + pvec[1] * trend * trend + pvec[2] * trend + pvec[3]\n            return trend\n\n        else:\n            # All other values parsed to `interpol_nodes` are not valid. Default to no trend component.\n            trend: NDArray[np.float64] = np.zeros(n_periods)\n            return trend\n\n    def generate_ARMA(\n        self,\n        AR: list[float],\n        MA: list[float],\n        randomwalk_scale: float,\n        n_periods: int,\n        exogenous: list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None = None,\n        seed: int | None = None,\n    ) -&gt; NDArray[np.float64]:\n        \"\"\"\n        !!! note \"Summary\"\n            Generate an ARMA (AutoRegressive Moving Average) time series.\n\n        ???+ info \"Details\"\n            - The ARMA model is a combination of autoregressive (AR) and moving average (MA) components.\n            - The function generates a time series based on the specified AR and MA coefficients, random walk scale, and optional exogenous variables.\n            - The generated time series is an array of the same length as `n_periods`, where each element represents the value of the ARMA time series at that period.\n            - The function uses numpy's random number generator to generate the noise component of the ARMA model.\n\n        Params:\n            AR (list[float]):\n                List of autoregressive coefficients.\n                The length of the list determines the order of the AR component.\n                All values must be between `0` and `1`.\n            MA (list[float]):\n                List of moving average coefficients.\n                The length of the list determines the order of the MA component.\n                All values must be between `0` and `1`.\n            randomwalk_scale (float):\n                Scale parameter for the random walk component.\n                This controls the standard deviation of the noise added to the time series.\n            n_periods (int):\n                The number of periods for which to generate the ARMA time series.\n                This determines the length of the output array.\n            exogenous (list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None):\n                Optional list of exogenous variables, where each variable is represented as a dictionary with keys \"coeff\" and \"ts\".\n                \"coeff\" is a list of coefficients for the exogenous variable, and \"ts\" is a list of values for that variable.\n            seed (int | None):\n                Random seed for reproducibility.&lt;br&gt;\n                Default is `None`.\n\n        Raises:\n            (TypeCheckError):\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n        Returns:\n            (NDArray[np.float64]):\n                An array of the same length as `n_periods`, where each element represents the value of the ARMA time series at that period.\n\n        ???+ info \"Details about how the `AR` and `MA` Parameters work\"\n\n            This [`#!py generate_ARMA()`][synthetic_data_generators.time_series.TimeSeriesGenerator.generate_ARMA] method creates time series data using ARMA (AutoRegressive Moving Average) models.\n            The `#!py AR` parameter is used to model the long-term trends in the data, while the `#!py MA` parameter is used to model the short-term fluctuations.\n\n            **The `AR` (AutoRegressive) Parameter:**\n\n            - The `#!py AR` parameter is a list of coefficients that determine how much past values influence the current value.\n            - Each coefficient represents the weight given to a specific lag (previous time point).\n            - For example, with `#!py AR=[0.6, 0.3]`:\n                - The value at time `#!py t` is influenced by:\n                - 60% of the value at time `#!py t-1` (0.6 x previous value)\n                - 30% of the value at time `#!py t-2` (0.3 x value from two periods ago)\n            - This creates persistence in the data where values tend to follow past trends. Higher AR values (closer to `#!py 1`) create stronger trends and more correlation with past values.\n            - Higher AR values (closer to `#!py 1`) create stronger trends and more correlation with past values.\n            - When `#!py AR=[0]`, the time series is purely random, as it does not depend on past values. Likewise, when `#!py AR=[1]`, the time series is the same as a random walk, as it only depends on the previous value.\n            - When multiple values are provided, the first value is the most recent, and the last value is the oldest. For example, `#!py AR=[0.5, 0.3]` means that the most recent value has a weight of `0.5`, and the second most recent value has a weight of `0.3`. Realistically, the second most recent value will have less influence than the most recent value, and will therefore have a lower value (closer to `#!py 0`), but it can still affect the current value.\n\n            **The `#!py MA` (Moving Average) Parameter:**\n\n            - The MA parameter is a list of coefficients that determine how much past random shocks (errors) influence the current value.\n            - For example, with `#!py MA=[0.2, 0.1]`:\n                - The value at time `#!py t` is influenced by:\n                - 20% of the random shock at time `#!py t-1`\n                - 10% of the random shock at time `#!py t-2`\n            - This creates short-term corrections or adjustments based on recent random fluctuations.\n            - Higher MA values (closer to `#!py 1`) create stronger corrections and more correlation with past shocks.\n            - When `#!py MA=[0]`, the time series is purely autoregressive, as it will depend on past values and does not depend on past shocks. Likewise, when `#!py MA=[1]`, the time series is purely random and will not depend on previous values.\n            - When multiple values are provided, the first value is the most recent, and the last value is the oldest. For example, `#!py MA=[0.5, 0.3]` means that the most recent value has a weight of `0.5`, and the second most recent value has a weight of `0.3`. Realistically, the second most recent value will have less influence than the most recent value, and will therefore have a lower value (closer to `#!py 0`), but it can still affect the current value.\n\n            **Examples and Effects:**\n\n            | Value                                | Description |\n            |--------------------------------------|-------------|\n            | `#!py AR=[0.9]`                      | Creates strong persistence - values strongly follow the previous value, resulting in smooth, trending data |\n            | `#!py AR=[0.5,0.3]`                  | Creates moderate persistence with some oscillation patterns |\n            | `#!py MA=[0.8]`                      | Creates immediate corrections after random shocks |\n            | `#!py MA=[0.5,0.3]`                  | Creates moderate corrections with some oscillation patterns |\n            | `#!py AR=[0.7]` &lt;br&gt; `#!py MA=[0.4]` | Combines trend persistence with short-term corrections |\n        \"\"\"\n\n        # Validations\n        AR = AR or [1]\n        MA = MA or [0]\n        exogenous = exogenous or []\n        assert exogenous is not None\n        self._assert_all_values_are_between(AR, min_value=0, max_value=1)\n        self._assert_all_values_are_between(MA, min_value=0, max_value=1)\n\n        # Noise\n        u: NDArray[np.float64] = self._random_generator(seed=seed).normal(\n            loc=0.0,\n            scale=randomwalk_scale,\n            size=n_periods,\n        )\n        ts: NDArray[np.float64] = np.zeros(n_periods).astype(np.float64)\n        for i in range(n_periods):\n            for i_ar in range(min(len(AR), i)):\n                ts[i] = ts[i] + AR[i_ar] * ts[i - 1 - i_ar]\n            ts[i] = ts[i] + u[i]\n            for i_ma in range(min(len(MA), i)):\n                ts[i] = ts[i] - MA[i_ma] * u[i - 1 - i_ma]\n            for exvar in exogenous:\n                for i_ar in range(len(exvar[\"coeff\"])):\n                    ts[i] = ts[i] + exvar[\"coeff\"][i_ar] * exvar[\"ts\"][i - i_ar]\n        return ts\n\n    ## --------------------------------------------------------------------------- #\n    ##  Validators                                                              ####\n    ## --------------------------------------------------------------------------- #\n\n    def _value_is_between(self, value: float, min_value: float, max_value: float) -&gt; bool:\n        \"\"\"\n        Check if a value is between two other values.\n\n        Params:\n            value (float):\n                The value to check.\n            min_value (float):\n                The minimum value.\n            max_value (float):\n                The maximum value.\n\n        Returns:\n            bool:\n                True if the value is between the minimum and maximum values, False otherwise.\n        \"\"\"\n        return min_value &lt;= value &lt;= max_value\n\n    def _assert_value_is_between(\n        self,\n        value: float,\n        min_value: float,\n        max_value: float,\n    ) -&gt; None:\n        \"\"\"\n        Assert that a value is between two other values.\n\n        Params:\n            value (float):\n                The value to check.\n            min_value (float):\n                The minimum value.\n            max_value (float):\n                The maximum value.\n\n        Raises:\n            AssertionError:\n                If the value is not between the minimum and maximum values.\n        \"\"\"\n        if not self._value_is_between(value, min_value, max_value):\n            raise AssertionError(f\"Value must be between `{min_value}` and `{max_value}`: `{value}`\")\n\n    def _all_values_are_between(\n        self,\n        values: list[float] | tuple[float, ...],\n        min_value: float,\n        max_value: float,\n    ) -&gt; bool:\n        \"\"\"\n        Check if all values in an array are between two other values.\n\n        Params:\n            values (Union[list[float], tuple[float, ...]]):\n                The array of values to check.\n            min_value (float):\n                The minimum value.\n            max_value (float):\n                The maximum value.\n\n        Returns:\n            bool:\n                True if all values are between the minimum and maximum values, False otherwise.\n        \"\"\"\n        return all(self._value_is_between(value, min_value, max_value) for value in values)\n\n    def _assert_all_values_are_between(\n        self,\n        values: list[float] | tuple[float, ...],\n        min_value: float,\n        max_value: float,\n    ) -&gt; None:\n        \"\"\"\n        Assert that all values in an array are between two other values.\n\n        Params:\n            values (Union[list[float], tuple[float, ...]]):\n                The array of values to check.\n            min_value (float):\n                The minimum value.\n            max_value (float):\n                The maximum value.\n\n        Raises:\n            AssertionError:\n                If any value is not between the minimum and maximum values.\n        \"\"\"\n        values_not_between: list[float] = [\n            value for value in values if not self._value_is_between(value, min_value, max_value)\n        ]\n        if not len(values_not_between) == 0:\n            raise AssertionError(f\"Values not between `{min_value}` and `{max_value}`: {values_not_between}\")\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Summary</p> <p>Initialize the TimeSeriesGenerator class.</p> Details <ul> <li>This class is designed to generate synthetic time series data for testing and validation purposes.</li> <li>It provides methods to create time series data with various characteristics, including seasonality, trends, and noise.</li> <li>The generated data can be used for testing algorithms, models, and other applications in time series analysis.</li> <li>The class includes methods for generating holiday indices, fixed error indices, semi-Markov indices, and sine indices.</li> <li>It also provides a method for generating polynomial trends and ARMA components.</li> <li>The generated time series data can be customized with different parameters, such as start date, number of periods, and noise scale.</li> <li>The class is designed to be flexible and extensible, allowing users to easily modify the generation process to suit their needs.</li> <li>It is built using Python's type hinting and type checking features to ensure that the inputs and outputs are of the expected types.</li> <li>This helps to catch potential errors early in the development process and improve code readability.</li> </ul> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Initialize the TimeSeriesGenerator class.\n\n    ???+ info \"Details\"\n        - This class is designed to generate synthetic time series data for testing and validation purposes.\n        - It provides methods to create time series data with various characteristics, including seasonality, trends, and noise.\n        - The generated data can be used for testing algorithms, models, and other applications in time series analysis.\n        - The class includes methods for generating holiday indices, fixed error indices, semi-Markov indices, and sine indices.\n        - It also provides a method for generating polynomial trends and ARMA components.\n        - The generated time series data can be customized with different parameters, such as start date, number of periods, and noise scale.\n        - The class is designed to be flexible and extensible, allowing users to easily modify the generation process to suit their needs.\n        - It is built using Python's type hinting and type checking features to ensure that the inputs and outputs are of the expected types.\n        - This helps to catch potential errors early in the development process and improve code readability.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.create_time_series","title":"create_time_series","text":"<pre><code>create_time_series(\n    start_date: datetime = datetime(2019, 1, 1),\n    n_periods: int = 1096,\n    interpolation_nodes: (\n        tuple[int_list_tuple, ...] | list[int_list_tuple]\n    ) = ([0, 98], [300, 92], [700, 190], [1096, 213]),\n    level_breaks: (\n        tuple[int_list_tuple, ...]\n        | list[int_list_tuple]\n        | None\n    ) = ([250, 100], [650, -50]),\n    AR: list[float] | None = None,\n    MA: list[float] | None = None,\n    randomwalk_scale: float = 2,\n    exogenous: (\n        list[dict[Literal[\"coeff\", \"ts\"], list[float]]]\n        | None\n    ) = None,\n    season_conf: dict_str_any | None = {\"style\": \"holiday\"},\n    season_eff: float = 0.15,\n    manual_outliers: (\n        tuple[int_list_tuple, ...]\n        | list[int_list_tuple]\n        | None\n    ) = None,\n    noise_scale: float = 10,\n    seed: int | None = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Summary</p> <p>Generate a synthetic time series with specified characteristics.</p> Details <ul> <li>The function generates a time series based on the specified parameters, including start date, number of periods, interpolation nodes, level breaks, ARMA coefficients, random walk scale, exogenous variables, seasonality configuration, manual outliers, and noise scale.</li> <li>The generated time series is returned as a pandas DataFrame with two columns: \"Date\" and \"Value\".</li> <li>The \"Date\" column contains the dates of the time series, and the \"Value\" column contains the corresponding values.</li> <li>The function also includes options for generating seasonality indices, fixed error indices, semi-Markov indices, and sine indices.</li> <li>The generated time series can be customized with different parameters, such as start date, number of periods, and noise scale.</li> </ul> <p>Important</p> <p>This function is designed to generate synthetic time series data for testing and validation purposes. It is not intended to be used for production or real-world applications.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The starting date for the time series. Default is <code>datetime(2019, 1, 1)</code>.</p> <code>datetime(2019, 1, 1)</code> <code>n_periods</code> <code>int</code> <p>The number of periods for the time series. Default is <code>1096</code>.</p> <code>1096</code> <code>interpolation_nodes</code> <code>tuple[int_list_tuple, ...] | list[int_list_tuple]</code> <p>A collection of interpolation nodes, where each node is a tuple containing the x-coordinate and y-coordinate. The x-coordinates should be in ascending order. Default is <code>([0, 98], [300, 92], [700, 190], [1096, 213])</code>.</p> <code>([0, 98], [300, 92], [700, 190], [1096, 213])</code> <code>level_breaks</code> <code>tuple[int_list_tuple, ...] | list[int_list_tuple] | None</code> <p>A collection of level breaks, where each break is a tuple containing the index and the value to add. Default is <code>([250, 100], [650, -50])</code>.</p> <code>([250, 100], [650, -50])</code> <code>AR</code> <code>list[float] | None</code> <p>The autoregressive coefficients for the ARMA model. Default is <code>None</code>.</p> <code>None</code> <code>MA</code> <code>list[float] | None</code> <p>The moving average coefficients for the ARMA model. Default is <code>None</code>.</p> <code>None</code> <code>randomwalk_scale</code> <code>float</code> <p>The scale of the random walk component. Default is <code>2</code>.</p> <code>2</code> <code>exogenous</code> <code>list[dict[Literal['coeff', 'ts'], list[float]]] | None</code> <p>A list of exogenous variables to include in the ARMA model. Default is <code>None</code>.</p> <code>None</code> <code>season_conf</code> <code>dict_str_any | None</code> <p>A dictionary containing the configuration for seasonality. Default is <code>{\"style\": \"holiday\"}</code>.</p> <code>{'style': 'holiday'}</code> <code>season_eff</code> <code>float</code> <p>The effectiveness of the seasonality component. Default is <code>0.15</code>.</p> <code>0.15</code> <code>manual_outliers</code> <code>tuple[int_list_tuple, ...] | list[int_list_tuple] | None</code> <p>A collection of manual outliers, where each outlier is a tuple containing the index and the value to set. Default is <code>None</code>.</p> <code>None</code> <code>noise_scale</code> <code>float</code> <p>The scale of the noise component. Default is <code>10</code>.</p> <code>10</code> <code>seed</code> <code>int | None</code> <p>The random seed for reproducibility. Default is <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>AssertionError</code> <p>If <code>interpolation_nodes</code> does not contain exactly two elements.</p> <code>TypeError</code> <p>If the first element of <code>interpolation_nodes</code> is not a <code>datetime</code>, or the second element is not an <code>int</code>.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame containing the generated time series data. The DataFrame has two columns: \"Date\" and \"Value\". The \"Date\" column contains the dates of the time series, and the \"Value\" column contains the corresponding values.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def create_time_series(\n    self,\n    start_date: datetime = datetime(2019, 1, 1),\n    n_periods: int = 1096,\n    interpolation_nodes: tuple[int_list_tuple, ...] | list[int_list_tuple] = (\n        [0, 98],\n        [300, 92],\n        [700, 190],\n        [1096, 213],\n    ),\n    level_breaks: tuple[int_list_tuple, ...] | list[int_list_tuple] | None = (\n        [250, 100],\n        [650, -50],\n    ),\n    AR: list[float] | None = None,\n    MA: list[float] | None = None,\n    randomwalk_scale: float = 2,\n    exogenous: list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None = None,\n    season_conf: dict_str_any | None = {\"style\": \"holiday\"},\n    season_eff: float = 0.15,\n    manual_outliers: tuple[int_list_tuple, ...] | list[int_list_tuple] | None = None,\n    noise_scale: float = 10,\n    seed: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a synthetic time series with specified characteristics.\n\n    ???+ info \"Details\"\n        - The function generates a time series based on the specified parameters, including start date, number of periods, interpolation nodes, level breaks, ARMA coefficients, random walk scale, exogenous variables, seasonality configuration, manual outliers, and noise scale.\n        - The generated time series is returned as a pandas DataFrame with two columns: \"Date\" and \"Value\".\n        - The \"Date\" column contains the dates of the time series, and the \"Value\" column contains the corresponding values.\n        - The function also includes options for generating seasonality indices, fixed error indices, semi-Markov indices, and sine indices.\n        - The generated time series can be customized with different parameters, such as start date, number of periods, and noise scale.\n\n    !!! warning \"Important\"\n        This function is designed to generate synthetic time series data for testing and validation purposes.\n        It is not intended to be used for production or real-world applications.\n\n    Params:\n        start_date (datetime):\n            The starting date for the time series.&lt;br&gt;\n            Default is `datetime(2019, 1, 1)`.\n        n_periods (int):\n            The number of periods for the time series.&lt;br&gt;\n            Default is `1096`.\n        interpolation_nodes (tuple[int_list_tuple, ...] | list[int_list_tuple]):\n            A collection of interpolation nodes, where each node is a tuple containing the x-coordinate and y-coordinate.&lt;br&gt;\n            The x-coordinates should be in ascending order.&lt;br&gt;\n            Default is `([0, 98], [300, 92], [700, 190], [1096, 213])`.\n        level_breaks (tuple[int_list_tuple, ...] | list[int_list_tuple] | None):\n            A collection of level breaks, where each break is a tuple containing the index and the value to add.&lt;br&gt;\n            Default is `([250, 100], [650, -50])`.\n        AR (list[float] | None):\n            The autoregressive coefficients for the ARMA model.&lt;br&gt;\n            Default is `None`.\n        MA (list[float] | None):\n            The moving average coefficients for the ARMA model.&lt;br&gt;\n            Default is `None`.\n        randomwalk_scale (float):\n            The scale of the random walk component.&lt;br&gt;\n            Default is `2`.\n        exogenous (list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None):\n            A list of exogenous variables to include in the ARMA model.&lt;br&gt;\n            Default is `None`.\n        season_conf (dict_str_any | None):\n            A dictionary containing the configuration for seasonality.&lt;br&gt;\n            Default is `{\"style\": \"holiday\"}`.\n        season_eff (float):\n            The effectiveness of the seasonality component.&lt;br&gt;\n            Default is `0.15`.\n        manual_outliers (tuple[int_list_tuple, ...] | list[int_list_tuple] | None):\n            A collection of manual outliers, where each outlier is a tuple containing the index and the value to set.&lt;br&gt;\n            Default is `None`.\n        noise_scale (float):\n            The scale of the noise component.&lt;br&gt;\n            Default is `10`.\n        seed (int | None):\n            The random seed for reproducibility.&lt;br&gt;\n            Default is `None`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        (AssertionError):\n            If `interpolation_nodes` does not contain exactly two elements.\n        (TypeError):\n            If the first element of `interpolation_nodes` is not a `datetime`, or the second element is not an `int`.\n\n    Returns:\n        (pd.DataFrame):\n            A pandas DataFrame containing the generated time series data.\n            The DataFrame has two columns: \"Date\" and \"Value\".\n            The \"Date\" column contains the dates of the time series, and the \"Value\" column contains the corresponding values.\n    \"\"\"\n\n    # Validations\n    AR = AR or [1]\n    MA = MA or [0]\n    exogenous = exogenous or []\n    manual_outliers = manual_outliers or []\n    assert AR is not None\n    assert MA is not None\n    assert manual_outliers is not None\n\n    # Date index:\n    dates: datetime_list = pd.date_range(start_date, periods=n_periods).to_pydatetime().tolist()\n\n    # Cubic trend component:\n    trend: NDArray[np.float64] = self.generate_polynom_trend(interpolation_nodes, n_periods)\n\n    # Structural break:\n    break_effect: NDArray[np.float64] = np.zeros(n_periods).astype(np.float64)\n    if level_breaks:\n        for level_break in level_breaks:\n            break_effect[level_break[0] :] += level_break[1]\n\n    # ARMA(AR,MA) component:\n    randomwalk: NDArray[np.float64] = self.generate_ARMA(\n        AR=AR,\n        MA=MA,\n        randomwalk_scale=randomwalk_scale,\n        n_periods=n_periods,\n        exogenous=exogenous,\n        seed=seed,\n    )\n\n    # Season:\n    if season_conf is not None:\n        season: NDArray[np.float64] = self.generate_season_index(dates=dates, **season_conf)  # type: ignore\n        season = season * season_eff + (1 - season)\n    else:\n        season = np.ones(n_periods)\n\n    # Noise component on top:\n    noise: NDArray[np.float64] = self._random_generator(seed=seed).normal(\n        loc=0.0,\n        scale=noise_scale,\n        size=n_periods,\n    )\n\n    # Assemble finally:\n    df: pd.DataFrame = pd.DataFrame(\n        list(\n            zip(\n                dates,\n                (trend + break_effect + randomwalk + noise) * season,\n            )\n        ),\n        index=dates,\n        columns=[\"Date\", \"Value\"],\n    )\n\n    # Manual outliers:\n    if manual_outliers:\n        for manual_outlier in manual_outliers:\n            df.iloc[manual_outlier[0], 1] = manual_outlier[1]\n\n    return df\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_holiday_index","title":"generate_holiday_index","text":"<pre><code>generate_holiday_index(\n    dates: datetime_list_tuple,\n    season_dates: Collection_of_Collection_of_datetime_or_int,\n) -&gt; NDArray[np.int_]\n</code></pre> <p>Summary</p> <p>Generate a holiday index for the given dates based on the provided holiday dates.</p> Details <ul> <li>A holiday index is a manual selection for date in <code>dates</code> to determine whether it is a holiday or not.</li> <li>Basically, it is a manual index of dates in a univariate time series data set which are actual holidays.</li> <li>The return array is generated by checking if each date in <code>dates</code> is present in the list of holiday dates generated from <code>season_dates</code>.</li> </ul> <p>Important</p> <p>This function is designed to work with a <code>.generate_season_index()</code> when the <code>style=\"holiday\"</code>. It is not intended to be called directly.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>datetime_list_tuple</code> <p>List of datetime objects representing the dates to check.</p> required <code>season_dates</code> <code>Collection_of_Collection_of_datetime_or_int</code> <p>Collection of collections containing holiday dates and their respective periods. Each element in the collection should contain exactly two elements: a datetime object and an integer representing the number of periods. Some example inputs include:</p> <ul> <li>List of lists containing datetime and periods: <code>season_dates = [[datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4]]</code></li> <li>List of tuples containing datetime and periods: <code>season_dates = [(datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4)]</code></li> <li>Tuple of lists containing datetime and periods: <code>season_dates = ([datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4])</code></li> <li>Tuple of tuples containing datetime and periods: <code>season_dates = ((datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4))</code></li> </ul> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>AssertionError</code> <p>If <code>season_dates</code> does not contain exactly two elements.</p> <code>TypeError</code> <p>If the first element of <code>season_dates</code> is not a <code>datetime</code>, or the second element is not an <code>int</code>.</p> <p>Returns:</p> Type Description <code>NDArray[int_]</code> <p>An array of the same length as <code>dates</code>, where each element is <code>1</code> if the corresponding date is a holiday, and <code>0</code> otherwise.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>@typechecked\ndef generate_holiday_index(\n    self,\n    dates: datetime_list_tuple,\n    season_dates: Collection_of_Collection_of_datetime_or_int,\n) -&gt; NDArray[np.int_]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a holiday index for the given dates based on the provided holiday dates.\n\n    ???+ info \"Details\"\n        - A holiday index is a manual selection for date in `dates` to determine whether it is a holiday or not.\n        - Basically, it is a manual index of dates in a univariate time series data set which are actual holidays.\n        - The return array is generated by checking if each date in `dates` is present in the list of holiday dates generated from `season_dates`.\n\n    !!! warning \"Important\"\n        This function is designed to work with a `.generate_season_index()` when the `style=\"holiday\"`.&lt;br&gt;\n        It is not intended to be called directly.\n\n    Params:\n        dates (datetime_list_tuple):\n            List of datetime objects representing the dates to check.\n        season_dates (Collection_of_Collection_of_datetime_or_int):\n            Collection of collections containing holiday dates and their respective periods.&lt;br&gt;\n            Each element in the collection should contain exactly two elements: a datetime object and an integer representing the number of periods.&lt;br&gt;\n            Some example inputs include:\\n\n            - List of lists containing datetime and periods: `season_dates = [[datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4]]`\n            - List of tuples containing datetime and periods: `season_dates = [(datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4)]`\n            - Tuple of lists containing datetime and periods: `season_dates = ([datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4])`\n            - Tuple of tuples containing datetime and periods: `season_dates = ((datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4))`\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        (AssertionError):\n            If `season_dates` does not contain exactly two elements.\n        (TypeError):\n            If the first element of `season_dates` is not a `datetime`, or the second element is not an `int`.\n\n    Returns:\n        (NDArray[np.int_]):\n            An array of the same length as `dates`, where each element is `1` if the corresponding date is a holiday, and `0` otherwise.\n    \"\"\"\n\n    # Validations\n    assert all(len(elem) == 2 for elem in season_dates)\n    assert_all_values_of_type([season_date[0] for season_date in season_dates], datetime)\n    assert_all_values_of_type([season_date[1] for season_date in season_dates], int)\n\n    # Build dates\n    season_dates_list: list[datetime] = []\n    for _dates in season_dates:\n        season_dates_list.extend(\n            self._generate_holiday_period(\n                start_date=_dates[0],  # type: ignore\n                periods=_dates[1],  # type: ignore\n            )\n        )\n\n    # Tag dates\n    events: NDArray[np.int_] = np.where([_date in season_dates_list for _date in dates], 1, 0)\n\n    # Return\n    return events\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_fixed_error_index","title":"generate_fixed_error_index","text":"<pre><code>generate_fixed_error_index(\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    period_sd: float = 0.5,\n    start_index: int = 4,\n    seed: int | None = None,\n    verbose: bool = False,\n) -&gt; NDArray[np.int_]\n</code></pre> <p>Summary</p> <p>Generate a fixed error seasonality index for the given dates.</p> Details <ul> <li>A holiday index is a manual selection for date in <code>dates</code> to determine whether it is a holiday or not.</li> <li>A fixed error seasonality index is a non-uniform distribution of dates in a univariate time series data set.</li> <li>Basically, it is indicating every <code>period_length</code> length of days, occurring every <code>period_sd</code> number of days, starting from <code>start_index</code>.</li> <li>The return array is a boolean <code>1</code> or <code>0</code> of length <code>n_periods</code>. It will have a seasonality of <code>period_length</code> and a disturbance standard deviation of <code>period_sd</code>. The result can be used as a non-uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).</li> </ul> <p>Important</p> <p>This function is designed to work with a <code>.generate_season_index()</code> when the <code>style=\"fixed+error\"</code>. It is not intended to be called directly.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>datetime_list_tuple</code> <p>List of datetime objects representing the dates to check.</p> required <code>period_length</code> <code>int</code> <p>The length of the period for seasonality. For example, if the frequency is weekly, this would be <code>7</code>. Default is <code>7</code>.</p> <code>7</code> <code>period_sd</code> <code>float</code> <p>The standard deviation of the disturbance. Default is <code>0.5</code>.</p> <code>0.5</code> <code>start_index</code> <code>int</code> <p>The starting index for the seasonality. Default is <code>4</code>.</p> <code>4</code> <code>verbose</code> <code>bool</code> <p>If <code>True</code>, print additional information about the generated indices. Helpful for debugging. Default is <code>False</code>.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>NDArray[int_]</code> <p>An array of the same length as <code>dates</code>, where each element is <code>1</code> if the corresponding date is a holiday, and <code>0</code> otherwise.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>@typechecked\ndef generate_fixed_error_index(\n    self,\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    period_sd: float = 0.5,\n    start_index: int = 4,\n    seed: int | None = None,\n    verbose: bool = False,\n) -&gt; NDArray[np.int_]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a fixed error seasonality index for the given dates.\n\n    ???+ info \"Details\"\n        - A holiday index is a manual selection for date in `dates` to determine whether it is a holiday or not.\n        - A fixed error seasonality index is a non-uniform distribution of dates in a univariate time series data set.\n        - Basically, it is indicating every `period_length` length of days, occurring every `period_sd` number of days, starting from `start_index`.\n        - The return array is a boolean `1` or `0` of length `n_periods`. It will have a seasonality of `period_length` and a disturbance standard deviation of `period_sd`. The result can be used as a non-uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).\n\n    !!! warning \"Important\"\n        This function is designed to work with a `.generate_season_index()` when the `style=\"fixed+error\"`.&lt;br&gt;\n        It is not intended to be called directly.\n\n    Params:\n        dates (datetime_list_tuple):\n            List of datetime objects representing the dates to check.\n        period_length (int):\n            The length of the period for seasonality.&lt;br&gt;\n            For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n            Default is `7`.\n        period_sd (float):\n            The standard deviation of the disturbance.&lt;br&gt;\n            Default is `0.5`.\n        start_index (int):\n            The starting index for the seasonality.&lt;br&gt;\n            Default is `4`.\n        verbose (bool):\n            If `True`, print additional information about the generated indices. Helpful for debugging.&lt;br&gt;\n            Default is `False`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (NDArray[np.int_]):\n            An array of the same length as `dates`, where each element is `1` if the corresponding date is a holiday, and `0` otherwise.\n    \"\"\"\n\n    # Process\n    n_periods: int = len(dates)\n    events: NDArray[np.int_] = np.zeros(n_periods).astype(np.int_)\n    event_inds: NDArray[Any] = np.arange(n_periods // period_length + 1) * period_length + start_index\n    disturbance: NDArray[np.int_] = (\n        self._random_generator(seed=seed)\n        .normal(\n            loc=0.0,\n            scale=period_sd,\n            size=len(event_inds),\n        )\n        .round()\n        .astype(int)\n    )\n    event_inds = event_inds + disturbance\n\n    # Delete indices that are out of bounds\n    if np.any(event_inds &gt;= n_periods):\n        event_inds = np.delete(event_inds, event_inds &gt;= n_periods)\n\n    # For any indices defined above, assign `1` to the events array\n    events[event_inds] = 1\n\n    # Check debugging\n    if verbose:\n        print(f\"Disturbance: {disturbance}\")\n        print(f\"Event indices: {event_inds}\")\n        print(f\"Weekdays: {np.mod(event_inds, period_length)}\")\n        print(f\"Histogram: {np.histogram(np.mod(event_inds, period_length), bins=np.arange(period_length))}\")\n\n    # Return\n    return events.astype(np.int_)\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_semi_markov_index","title":"generate_semi_markov_index","text":"<pre><code>generate_semi_markov_index(\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    period_sd: float = 0.5,\n    start_index: int = 4,\n    seed: int | None = None,\n    verbose: bool = False,\n) -&gt; NDArray[np.int_]\n</code></pre> <p>Summary</p> <p>Generate a semi-Markov seasonality index for the given dates.</p> Details <ul> <li>A semi-Markov seasonality index is a uniform distribution of dates in a univariate time series data set.</li> <li>Basically, it is indicating a <code>period_length</code> length of days, occurring randomly roughly ever <code>period_sd</code> number of days, starting from <code>start_index</code>.</li> <li>The return array is a boolean <code>1</code> or <code>0</code> of length <code>n_periods</code>. It will have a seasonality of <code>period_length</code> and a disturbance standard deviation of <code>period_sd</code>. The result can be used as a uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>datetime_list_tuple</code> <p>List of datetime objects representing the dates to check.</p> required <code>period_length</code> <code>int</code> <p>The length of the period for seasonality. For example, if the frequency is weekly, this would be <code>7</code>. Default is <code>7</code>.</p> <code>7</code> <code>period_sd</code> <code>float</code> <p>The standard deviation of the disturbance. Default is <code>0.5</code>.</p> <code>0.5</code> <code>start_index</code> <code>int</code> <p>The starting index for the seasonality. Default is <code>4</code>.</p> <code>4</code> <code>verbose</code> <code>bool</code> <p>If <code>True</code>, print additional information about the generated indices. Helpful for debugging. Default is <code>False</code>.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>NDArray[int_]</code> <p>An array of the same length as <code>dates</code>, where each element is <code>1</code> if the corresponding date is a holiday, and <code>0</code> otherwise.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def generate_semi_markov_index(\n    self,\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    period_sd: float = 0.5,\n    start_index: int = 4,\n    seed: int | None = None,\n    verbose: bool = False,\n) -&gt; NDArray[np.int_]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a semi-Markov seasonality index for the given dates.\n\n    ???+ info \"Details\"\n        - A semi-Markov seasonality index is a uniform distribution of dates in a univariate time series data set.\n        - Basically, it is indicating a `period_length` length of days, occurring randomly roughly ever `period_sd` number of days, starting from `start_index`.\n        - The return array is a boolean `1` or `0` of length `n_periods`. It will have a seasonality of `period_length` and a disturbance standard deviation of `period_sd`. The result can be used as a uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).\n\n    Params:\n        dates (datetime_list_tuple):\n            List of datetime objects representing the dates to check.\n        period_length (int):\n            The length of the period for seasonality.&lt;br&gt;\n            For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n            Default is `7`.\n        period_sd (float):\n            The standard deviation of the disturbance.&lt;br&gt;\n            Default is `0.5`.\n        start_index (int):\n            The starting index for the seasonality.&lt;br&gt;\n            Default is `4`.\n        verbose (bool):\n            If `True`, print additional information about the generated indices. Helpful for debugging.&lt;br&gt;\n            Default is `False`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (NDArray[np.int_]):\n            An array of the same length as `dates`, where each element is `1` if the corresponding date is a holiday, and `0` otherwise.\n    \"\"\"\n\n    # Process\n    n_periods: int = len(dates)\n    events: NDArray[np.int_] = np.zeros(n_periods).astype(np.int_)\n    event_inds: list[int] = [start_index]\n    new = np.random.normal(loc=period_length, scale=period_sd, size=1).round()[0]\n    while new + event_inds[-1] &lt; n_periods:\n        event_inds.append(new + event_inds[-1])\n        new = (\n            self._random_generator(seed=seed)\n            .normal(\n                loc=period_length,\n                scale=period_sd,\n                size=1,\n            )\n            .round()[0]\n        )\n    event_indexes: NDArray[np.int_] = np.array(event_inds).astype(np.int_)\n\n    # For any indices defined above, assign `1` to the events array\n    events[event_indexes] = 1\n\n    # Check debugging\n    if verbose:\n        print(f\"Event indices: {event_inds}\")\n        print(f\"Weekdays: {np.mod(event_inds, period_length)}\")\n        print(f\"Histogram: {np.histogram(np.mod(event_inds, period_length), bins=np.arange(period_length))}\")\n\n    # Return\n    return events\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_sin_index","title":"generate_sin_index","text":"<pre><code>generate_sin_index(\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    start_index: int = 4,\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Summary</p> <p>Generate a sine seasonality index for the given dates.</p> Details <ul> <li>A sine seasonality index is a periodic function that oscillates between <code>0</code> and <code>1</code>.</li> <li>It is used to model seasonal patterns in time series data.</li> <li>The return array is a sine wave of length <code>n_periods</code>, with a period of <code>period_length</code> and a phase shift of <code>start_index</code>.</li> <li>The result can be used to represent seasonal patterns in time series data, such as daily or weekly cycles.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>datetime_list_tuple</code> <p>List of datetime objects representing the dates to check.</p> required <code>period_length</code> <code>int</code> <p>The length of the period for seasonality. For example, if the frequency is weekly, this would be <code>7</code>. Default is <code>7</code>.</p> <code>7</code> <code>start_index</code> <code>int</code> <p>The starting index for the seasonality. Designed to account for seasonal patterns that start at a different point in time. Default is <code>4</code>.</p> <code>4</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of the same length as <code>dates</code>, where each element is a sine value representing the seasonal pattern.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def generate_sin_index(\n    self,\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    start_index: int = 4,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a sine seasonality index for the given dates.\n\n    ???+ info \"Details\"\n        - A sine seasonality index is a periodic function that oscillates between `0` and `1`.\n        - It is used to model seasonal patterns in time series data.\n        - The return array is a sine wave of length `n_periods`, with a period of `period_length` and a phase shift of `start_index`.\n        - The result can be used to represent seasonal patterns in time series data, such as daily or weekly cycles.\n\n    Params:\n        dates (datetime_list_tuple):\n            List of datetime objects representing the dates to check.\n        period_length (int):\n            The length of the period for seasonality.&lt;br&gt;\n            For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n            Default is `7`.\n        start_index (int):\n            The starting index for the seasonality. Designed to account for seasonal patterns that start at a different point in time.&lt;br&gt;\n            Default is `4`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (NDArray[np.float64]):\n            An array of the same length as `dates`, where each element is a sine value representing the seasonal pattern.\n    \"\"\"\n    n_periods: int = len(dates)\n    events = (np.sin((np.arange(n_periods) - start_index) / period_length * 2 * np.pi) + 1) / 2\n    return events\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_sin_covar_index","title":"generate_sin_covar_index","text":"<pre><code>generate_sin_covar_index(\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    start_index: int = 4,\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Summary</p> <p>Generate a sine seasonality index with covariance for the given dates.</p> Details <ul> <li>A sine seasonality index with covariance is a periodic function that oscillates between <code>0</code> and <code>1</code>.</li> <li>It is used to model seasonal patterns in time series data, taking into account the covariance structure of the data.</li> <li>The return array is a sine wave of length <code>n_periods</code>, with a period of <code>period_length</code> and a phase shift of <code>start_index</code>.</li> <li>The result can be used to represent seasonal patterns in time series data, such as daily or weekly cycles.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>datetime_list_tuple</code> <p>List of datetime objects representing the dates to check.</p> required <code>period_length</code> <code>int</code> <p>The length of the period for seasonality. For example, if the frequency is weekly, this would be <code>7</code>. Default is <code>7</code>.</p> <code>7</code> <code>start_index</code> <code>int</code> <p>The starting index for the seasonality. Designed to account for seasonal patterns that start at a different point in time. Default is <code>4</code>.</p> <code>4</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of the same length as <code>dates</code>, where each element is a sine value representing the seasonal pattern.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def generate_sin_covar_index(\n    self,\n    dates: datetime_list_tuple,\n    period_length: int = 7,\n    start_index: int = 4,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a sine seasonality index with covariance for the given dates.\n\n    ???+ info \"Details\"\n        - A sine seasonality index with covariance is a periodic function that oscillates between `0` and `1`.\n        - It is used to model seasonal patterns in time series data, taking into account the covariance structure of the data.\n        - The return array is a sine wave of length `n_periods`, with a period of `period_length` and a phase shift of `start_index`.\n        - The result can be used to represent seasonal patterns in time series data, such as daily or weekly cycles.\n\n    Params:\n        dates (datetime_list_tuple):\n            List of datetime objects representing the dates to check.\n        period_length (int):\n            The length of the period for seasonality.&lt;br&gt;\n            For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n            Default is `7`.\n        start_index (int):\n            The starting index for the seasonality. Designed to account for seasonal patterns that start at a different point in time.&lt;br&gt;\n            Default is `4`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (NDArray[np.float64]):\n            An array of the same length as `dates`, where each element is a sine value representing the seasonal pattern.\n    \"\"\"\n    n_periods: int = len(dates)\n    covar_wave = (np.sin((np.arange(n_periods) - start_index) / period_length / 6 * np.pi) + 2) / 2\n    dx: NDArray[np.float64] = np.full_like(covar_wave, 0.4)\n    sin_wave: NDArray[np.float64] = np.sin((covar_wave * dx).cumsum())\n    return sin_wave\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_season_index","title":"generate_season_index","text":"<pre><code>generate_season_index(\n    dates: datetime_list_tuple,\n    style: Literal[\n        \"fixed+error\",\n        \"semi-markov\",\n        \"holiday\",\n        \"sin\",\n        \"sin_covar\",\n    ],\n    season_dates: (\n        Collection_of_Collection_of_datetime_or_int | None\n    ) = None,\n    period_length: int | None = None,\n    period_sd: float | None = None,\n    start_index: int | None = None,\n    seed: int | None = None,\n    verbose: bool = False,\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Summary</p> <p>Generate a seasonality index for the given dates based on the specified style.</p> Details <ul> <li>A seasonality index is a manual selection for date in <code>dates</code> to determine whether it is a holiday or not.</li> <li>Basically, it is a manual index of dates in a univariate time series data set which are actual holidays.</li> <li>The return array is generated by checking if each date in <code>dates</code> is present in the list of holiday dates generated from <code>season_dates</code>.</li> <li>The return array is a boolean <code>1</code> or <code>0</code> of length <code>n_periods</code>. It will have a seasonality of <code>period_length</code> and a disturbance standard deviation of <code>period_sd</code>. The result can be used as a non-uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>datetime_list_tuple</code> <p>List of datetime objects representing the dates to check.</p> required <code>style</code> <code>Literal</code> <p>The style of the seasonality index to generate. Possible values are: - <code>\"fixed+error\"</code>: Fixed error seasonality index. - <code>\"semi-markov\"</code>: Semi-Markov seasonality index. - <code>\"holiday\"</code>: Holiday seasonality index. - <code>\"sin\"</code>: Sine seasonality index. - <code>\"sin_covar\"</code>: Sine seasonality index with covariance.</p> required <code>season_dates</code> <code>Collection_of_Collection_of_datetime_or_int | None</code> <p>Collection of collections containing holiday dates and their respective periods. Each element in the collection should contain exactly two elements: a datetime object and an integer representing the number of periods. Some example inputs include:</p> <ul> <li>List of lists containing datetime and periods: <code>season_dates = [[datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4]]</code></li> <li>List of tuples containing datetime and periods: <code>season_dates = [(datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4)]</code></li> <li>Tuple of lists containing datetime and periods: <code>season_dates = ([datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4])</code></li> <li>Tuple of tuples containing datetime and periods: <code>season_dates = ((datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4))</code></li> </ul> <code>None</code> <code>period_length</code> <code>int | None</code> <p>The length of the period for seasonality. For example, if the frequency is weekly, this would be <code>7</code>. Default is <code>7</code>.</p> <code>None</code> <code>period_sd</code> <code>float | None</code> <p>The standard deviation of the disturbance. Default is <code>0.5</code>.</p> <code>None</code> <code>start_index</code> <code>int | None</code> <p>The starting index for the seasonality. Default is <code>4</code>.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>Random seed for reproducibility. Default is <code>None</code>.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If <code>True</code>, print additional information about the generated indices. Helpful for debugging. Default is <code>False</code>.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>AssertionError</code> <p>If <code>season_dates</code> does not contain exactly two elements.</p> <code>TypeError</code> <p>If the first element of <code>season_dates</code> is not a <code>datetime</code>, or the second element is not an <code>int</code>.</p> <code>ValueError</code> <p>If <code>style</code> is not one of the supported styles. If <code>period_length</code>, <code>period_sd</code>, or <code>start_index</code> are not provided for the corresponding styles.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of the same length as <code>dates</code>, where each element is a sine value representing the seasonal pattern.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def generate_season_index(\n    self,\n    dates: datetime_list_tuple,\n    style: Literal[\n        \"fixed+error\",\n        \"semi-markov\",\n        \"holiday\",\n        \"sin\",\n        \"sin_covar\",\n    ],\n    season_dates: Collection_of_Collection_of_datetime_or_int | None = None,\n    period_length: int | None = None,\n    period_sd: float | None = None,\n    start_index: int | None = None,\n    seed: int | None = None,\n    verbose: bool = False,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a seasonality index for the given dates based on the specified style.\n\n    ???+ info \"Details\"\n        - A seasonality index is a manual selection for date in `dates` to determine whether it is a holiday or not.\n        - Basically, it is a manual index of dates in a univariate time series data set which are actual holidays.\n        - The return array is generated by checking if each date in `dates` is present in the list of holiday dates generated from `season_dates`.\n        - The return array is a boolean `1` or `0` of length `n_periods`. It will have a seasonality of `period_length` and a disturbance standard deviation of `period_sd`. The result can be used as a non-uniform distribution of weekdays in a histogram (if for eg. frequency is weekly).\n\n    Params:\n        dates (datetime_list_tuple):\n            List of datetime objects representing the dates to check.\n        style (Literal):\n            The style of the seasonality index to generate.&lt;br&gt;\n            Possible values are:\n            - `\"fixed+error\"`: Fixed error seasonality index.\n            - `\"semi-markov\"`: Semi-Markov seasonality index.\n            - `\"holiday\"`: Holiday seasonality index.\n            - `\"sin\"`: Sine seasonality index.\n            - `\"sin_covar\"`: Sine seasonality index with covariance.\n        season_dates (Collection_of_Collection_of_datetime_or_int | None):\n            Collection of collections containing holiday dates and their respective periods.&lt;br&gt;\n            Each element in the collection should contain exactly two elements: a datetime object and an integer representing the number of periods.&lt;br&gt;\n            Some example inputs include:\\n\n            - List of lists containing datetime and periods: `season_dates = [[datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4]]`\n            - List of tuples containing datetime and periods: `season_dates = [(datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4)]`\n            - Tuple of lists containing datetime and periods: `season_dates = ([datetime(2025, 4, 18), 4], [datetime(2024, 3, 29), 4])`\n            - Tuple of tuples containing datetime and periods: `season_dates = ((datetime(2025, 4, 18), 4), (datetime(2024, 3, 29), 4))`\n        period_length (int | None):\n            The length of the period for seasonality.&lt;br&gt;\n            For example, if the frequency is weekly, this would be `7`.&lt;br&gt;\n            Default is `7`.\n        period_sd (float | None):\n            The standard deviation of the disturbance.&lt;br&gt;\n            Default is `0.5`.\n        start_index (int | None):\n            The starting index for the seasonality.&lt;br&gt;\n            Default is `4`.\n        seed (int | None):\n            Random seed for reproducibility.&lt;br&gt;\n            Default is `None`.\n        verbose (bool):\n            If `True`, print additional information about the generated indices. Helpful for debugging.&lt;br&gt;\n            Default is `False`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        (AssertionError):\n            If `season_dates` does not contain exactly two elements.\n        (TypeError):\n            If the first element of `season_dates` is not a `datetime`, or the second element is not an `int`.\n        (ValueError):\n            If `style` is not one of the supported styles.\n            If `period_length`, `period_sd`, or `start_index` are not provided for the corresponding styles.\n\n    Returns:\n        (NDArray[np.float64]):\n            An array of the same length as `dates`, where each element is a sine value representing the seasonal pattern.\n    \"\"\"\n    if \"fixed\" in style and \"error\" in style:\n        assert period_length is not None\n        assert period_sd is not None\n        assert start_index is not None\n        return self.generate_fixed_error_index(\n            dates=dates,\n            period_length=period_length,\n            period_sd=period_sd,\n            start_index=start_index,\n            seed=seed,\n            verbose=verbose,\n        ).astype(np.float64)\n    elif \"semi\" in style and \"markov\" in style:\n        assert period_length is not None\n        assert period_sd is not None\n        assert start_index is not None\n        return self.generate_semi_markov_index(\n            dates=dates,\n            period_length=period_length,\n            period_sd=period_sd,\n            start_index=start_index,\n            seed=seed,\n            verbose=verbose,\n        ).astype(np.float64)\n    elif style == \"holiday\":\n        assert season_dates is not None\n        return self.generate_holiday_index(dates=dates, season_dates=season_dates).astype(np.float64)\n    elif \"sin\" in style and \"covar\" in style:\n        assert period_length is not None\n        assert start_index is not None\n        return self.generate_sin_covar_index(dates=dates, period_length=period_length).astype(np.float64)\n    elif style == \"sin\":\n        assert period_length is not None\n        assert start_index is not None\n        return self.generate_sin_index(dates=dates, period_length=period_length).astype(np.float64)\n    else:\n        return np.zeros(len(dates)).astype(np.float64)\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_polynom_trend","title":"generate_polynom_trend","text":"<pre><code>generate_polynom_trend(\n    interpol_nodes, n_periods: int\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Summary</p> <p>Generate a polynomial trend based on the provided interpolation nodes.</p> Details <ul> <li>The polynomial trend is generated using the provided interpolation nodes.</li> <li>The function supports polynomial trends of order 1 (linear), 2 (quadratic), 3 (cubic), and 4 (quartic).</li> <li>The generated trend is an array of the same length as <code>n_periods</code>, where each element represents the value of the polynomial trend at that period.</li> <li>The function uses numpy's linear algebra solver to compute the coefficients of the polynomial based on the provided interpolation nodes.</li> </ul> <p>Important</p> <p>This function is implemented only up to order 3 (cubic interpolation = four nodes). It is not intended to be used for higher-order polynomial trends.</p> <p>Parameters:</p> Name Type Description Default <code>interpol_nodes</code> <code>tuple[int_list_tuple, ...] | list[int_list_tuple]</code> <p>A collection of interpolation nodes, where each node is a tuple containing the x-coordinate and y-coordinate. The x-coordinates should be in ascending order.</p> required <code>n_periods</code> <code>int</code> <p>The number of periods for which to generate the polynomial trend. This determines the length of the output array. The generated trend will have the same length as <code>n_periods</code>.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>AssertionError</code> <p>If <code>interpol_nodes</code> does not contain exactly two elements.</p> <code>TypeError</code> <p>If the first element of <code>interpol_nodes</code> is not a <code>datetime</code>, or the second element is not an <code>int</code>.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of the same length as <code>n_periods</code>, where each element represents the value of the polynomial trend at that period.</p> Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def generate_polynom_trend(self, interpol_nodes, n_periods: int) -&gt; NDArray[np.float64]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate a polynomial trend based on the provided interpolation nodes.\n\n    ???+ info \"Details\"\n        - The polynomial trend is generated using the provided interpolation nodes.\n        - The function supports polynomial trends of order 1 (linear), 2 (quadratic), 3 (cubic), and 4 (quartic).\n        - The generated trend is an array of the same length as `n_periods`, where each element represents the value of the polynomial trend at that period.\n        - The function uses numpy's linear algebra solver to compute the coefficients of the polynomial based on the provided interpolation nodes.\n\n    !!! warning \"Important\"\n        This function is implemented only up to order 3 (cubic interpolation = four nodes).\n        It is not intended to be used for higher-order polynomial trends.\n\n    Params:\n        interpol_nodes (tuple[int_list_tuple, ...] | list[int_list_tuple]):\n            A collection of interpolation nodes, where each node is a tuple containing the x-coordinate and y-coordinate.\n            The x-coordinates should be in ascending order.\n        n_periods (int):\n            The number of periods for which to generate the polynomial trend.\n            This determines the length of the output array.\n            The generated trend will have the same length as `n_periods`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        (AssertionError):\n            If `interpol_nodes` does not contain exactly two elements.\n        (TypeError):\n            If the first element of `interpol_nodes` is not a `datetime`, or the second element is not an `int`.\n\n    Returns:\n        (NDArray[np.float64]):\n            An array of the same length as `n_periods`, where each element represents the value of the polynomial trend at that period.\n    \"\"\"\n\n    if len(interpol_nodes) == 0:\n        # No trend component:\n        trend: NDArray[np.float64] = np.zeros(n_periods)\n        return trend\n\n    elif len(interpol_nodes) == 1:\n        # No trend component:\n        trend: NDArray[np.float64] = np.zeros(n_periods) + interpol_nodes[0][1]\n        return trend\n\n    elif len(interpol_nodes) == 2:\n        # Linear trend component:\n        x1, y1 = interpol_nodes[0]\n        x2, y2 = interpol_nodes[1]\n        M = np.column_stack((np.array([x1, x2]), np.ones(2)))\n        b = np.array([y1, y2])\n        pvec = np.linalg.solve(M, b)\n        trend: NDArray[np.float64] = np.arange(n_periods).astype(np.float64)\n        trend = pvec[0] * trend + pvec[1]\n        return trend\n\n    elif len(interpol_nodes) == 3:\n        # Quadratic trend component:\n        x1, y1 = interpol_nodes[0]\n        x2, y2 = interpol_nodes[1]\n        x3, y3 = interpol_nodes[2]\n        M = np.column_stack(\n            (\n                np.array([x1, x2, x3]) * np.array([x1, x2, x3]),\n                np.array([x1, x2, x3]),\n                np.ones(3),\n            )\n        )\n        b = np.array([y1, y2, y3])\n        pvec = np.linalg.solve(M, b)\n        trend: NDArray[np.float64] = np.arange(n_periods).astype(np.float64)\n        trend = pvec[0] * trend * trend + pvec[1] * trend + pvec[2]\n        return trend\n\n    elif len(interpol_nodes) == 4:\n        # Cubic trend component:\n        x1, y1 = interpol_nodes[0]\n        x2, y2 = interpol_nodes[1]\n        x3, y3 = interpol_nodes[2]\n        x4, y4 = interpol_nodes[3]\n        M = np.column_stack(\n            (\n                np.array([x1, x2, x3, x4]) * np.array([x1, x2, x3, x4]) * np.array([x1, x2, x3, x4]),\n                np.array([x1, x2, x3, x4]) * np.array([x1, x2, x3, x4]),\n                np.array([x1, x2, x3, x4]),\n                np.ones(4),\n            )\n        )\n        b = np.array([y1, y2, y3, y4])\n        pvec = np.linalg.solve(M, b)\n        trend: NDArray[np.float64] = np.arange(n_periods).astype(np.float64)\n        trend = pvec[0] * trend * trend * trend + pvec[1] * trend * trend + pvec[2] * trend + pvec[3]\n        return trend\n\n    else:\n        # All other values parsed to `interpol_nodes` are not valid. Default to no trend component.\n        trend: NDArray[np.float64] = np.zeros(n_periods)\n        return trend\n</code></pre>"},{"location":"code/time_series/#synthetic_data_generators.time_series.TimeSeriesGenerator.generate_ARMA","title":"generate_ARMA","text":"<pre><code>generate_ARMA(\n    AR: list[float],\n    MA: list[float],\n    randomwalk_scale: float,\n    n_periods: int,\n    exogenous: (\n        list[dict[Literal[\"coeff\", \"ts\"], list[float]]]\n        | None\n    ) = None,\n    seed: int | None = None,\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Summary</p> <p>Generate an ARMA (AutoRegressive Moving Average) time series.</p> Details <ul> <li>The ARMA model is a combination of autoregressive (AR) and moving average (MA) components.</li> <li>The function generates a time series based on the specified AR and MA coefficients, random walk scale, and optional exogenous variables.</li> <li>The generated time series is an array of the same length as <code>n_periods</code>, where each element represents the value of the ARMA time series at that period.</li> <li>The function uses numpy's random number generator to generate the noise component of the ARMA model.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>AR</code> <code>list[float]</code> <p>List of autoregressive coefficients. The length of the list determines the order of the AR component. All values must be between <code>0</code> and <code>1</code>.</p> required <code>MA</code> <code>list[float]</code> <p>List of moving average coefficients. The length of the list determines the order of the MA component. All values must be between <code>0</code> and <code>1</code>.</p> required <code>randomwalk_scale</code> <code>float</code> <p>Scale parameter for the random walk component. This controls the standard deviation of the noise added to the time series.</p> required <code>n_periods</code> <code>int</code> <p>The number of periods for which to generate the ARMA time series. This determines the length of the output array.</p> required <code>exogenous</code> <code>list[dict[Literal['coeff', 'ts'], list[float]]] | None</code> <p>Optional list of exogenous variables, where each variable is represented as a dictionary with keys \"coeff\" and \"ts\". \"coeff\" is a list of coefficients for the exogenous variable, and \"ts\" is a list of values for that variable.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>Random seed for reproducibility. Default is <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of the same length as <code>n_periods</code>, where each element represents the value of the ARMA time series at that period.</p> Details about how the <code>AR</code> and <code>MA</code> Parameters work <p>This <code>generate_ARMA()</code> method creates time series data using ARMA (AutoRegressive Moving Average) models. The <code>AR</code> parameter is used to model the long-term trends in the data, while the <code>MA</code> parameter is used to model the short-term fluctuations.</p> <p>The <code>AR</code> (AutoRegressive) Parameter:</p> <ul> <li>The <code>AR</code> parameter is a list of coefficients that determine how much past values influence the current value.</li> <li>Each coefficient represents the weight given to a specific lag (previous time point).</li> <li>For example, with <code>AR=[0.6, 0.3]</code>:<ul> <li>The value at time <code>t</code> is influenced by:</li> <li>60% of the value at time <code>t-1</code> (0.6 x previous value)</li> <li>30% of the value at time <code>t-2</code> (0.3 x value from two periods ago)</li> </ul> </li> <li>This creates persistence in the data where values tend to follow past trends. Higher AR values (closer to <code>1</code>) create stronger trends and more correlation with past values.</li> <li>Higher AR values (closer to <code>1</code>) create stronger trends and more correlation with past values.</li> <li>When <code>AR=[0]</code>, the time series is purely random, as it does not depend on past values. Likewise, when <code>AR=[1]</code>, the time series is the same as a random walk, as it only depends on the previous value.</li> <li>When multiple values are provided, the first value is the most recent, and the last value is the oldest. For example, <code>AR=[0.5, 0.3]</code> means that the most recent value has a weight of <code>0.5</code>, and the second most recent value has a weight of <code>0.3</code>. Realistically, the second most recent value will have less influence than the most recent value, and will therefore have a lower value (closer to <code>0</code>), but it can still affect the current value.</li> </ul> <p>The <code>MA</code> (Moving Average) Parameter:</p> <ul> <li>The MA parameter is a list of coefficients that determine how much past random shocks (errors) influence the current value.</li> <li>For example, with <code>MA=[0.2, 0.1]</code>:<ul> <li>The value at time <code>t</code> is influenced by:</li> <li>20% of the random shock at time <code>t-1</code></li> <li>10% of the random shock at time <code>t-2</code></li> </ul> </li> <li>This creates short-term corrections or adjustments based on recent random fluctuations.</li> <li>Higher MA values (closer to <code>1</code>) create stronger corrections and more correlation with past shocks.</li> <li>When <code>MA=[0]</code>, the time series is purely autoregressive, as it will depend on past values and does not depend on past shocks. Likewise, when <code>MA=[1]</code>, the time series is purely random and will not depend on previous values.</li> <li>When multiple values are provided, the first value is the most recent, and the last value is the oldest. For example, <code>MA=[0.5, 0.3]</code> means that the most recent value has a weight of <code>0.5</code>, and the second most recent value has a weight of <code>0.3</code>. Realistically, the second most recent value will have less influence than the most recent value, and will therefore have a lower value (closer to <code>0</code>), but it can still affect the current value.</li> </ul> <p>Examples and Effects:</p> Value Description <code>AR=[0.9]</code> Creates strong persistence - values strongly follow the previous value, resulting in smooth, trending data <code>AR=[0.5,0.3]</code> Creates moderate persistence with some oscillation patterns <code>MA=[0.8]</code> Creates immediate corrections after random shocks <code>MA=[0.5,0.3]</code> Creates moderate corrections with some oscillation patterns <code>AR=[0.7]</code> <code>MA=[0.4]</code> Combines trend persistence with short-term corrections Source code in <code>src/synthetic_data_generators/time_series.py</code> <pre><code>def generate_ARMA(\n    self,\n    AR: list[float],\n    MA: list[float],\n    randomwalk_scale: float,\n    n_periods: int,\n    exogenous: list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None = None,\n    seed: int | None = None,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate an ARMA (AutoRegressive Moving Average) time series.\n\n    ???+ info \"Details\"\n        - The ARMA model is a combination of autoregressive (AR) and moving average (MA) components.\n        - The function generates a time series based on the specified AR and MA coefficients, random walk scale, and optional exogenous variables.\n        - The generated time series is an array of the same length as `n_periods`, where each element represents the value of the ARMA time series at that period.\n        - The function uses numpy's random number generator to generate the noise component of the ARMA model.\n\n    Params:\n        AR (list[float]):\n            List of autoregressive coefficients.\n            The length of the list determines the order of the AR component.\n            All values must be between `0` and `1`.\n        MA (list[float]):\n            List of moving average coefficients.\n            The length of the list determines the order of the MA component.\n            All values must be between `0` and `1`.\n        randomwalk_scale (float):\n            Scale parameter for the random walk component.\n            This controls the standard deviation of the noise added to the time series.\n        n_periods (int):\n            The number of periods for which to generate the ARMA time series.\n            This determines the length of the output array.\n        exogenous (list[dict[Literal[\"coeff\", \"ts\"], list[float]]] | None):\n            Optional list of exogenous variables, where each variable is represented as a dictionary with keys \"coeff\" and \"ts\".\n            \"coeff\" is a list of coefficients for the exogenous variable, and \"ts\" is a list of values for that variable.\n        seed (int | None):\n            Random seed for reproducibility.&lt;br&gt;\n            Default is `None`.\n\n    Raises:\n        (TypeCheckError):\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (NDArray[np.float64]):\n            An array of the same length as `n_periods`, where each element represents the value of the ARMA time series at that period.\n\n    ???+ info \"Details about how the `AR` and `MA` Parameters work\"\n\n        This [`#!py generate_ARMA()`][synthetic_data_generators.time_series.TimeSeriesGenerator.generate_ARMA] method creates time series data using ARMA (AutoRegressive Moving Average) models.\n        The `#!py AR` parameter is used to model the long-term trends in the data, while the `#!py MA` parameter is used to model the short-term fluctuations.\n\n        **The `AR` (AutoRegressive) Parameter:**\n\n        - The `#!py AR` parameter is a list of coefficients that determine how much past values influence the current value.\n        - Each coefficient represents the weight given to a specific lag (previous time point).\n        - For example, with `#!py AR=[0.6, 0.3]`:\n            - The value at time `#!py t` is influenced by:\n            - 60% of the value at time `#!py t-1` (0.6 x previous value)\n            - 30% of the value at time `#!py t-2` (0.3 x value from two periods ago)\n        - This creates persistence in the data where values tend to follow past trends. Higher AR values (closer to `#!py 1`) create stronger trends and more correlation with past values.\n        - Higher AR values (closer to `#!py 1`) create stronger trends and more correlation with past values.\n        - When `#!py AR=[0]`, the time series is purely random, as it does not depend on past values. Likewise, when `#!py AR=[1]`, the time series is the same as a random walk, as it only depends on the previous value.\n        - When multiple values are provided, the first value is the most recent, and the last value is the oldest. For example, `#!py AR=[0.5, 0.3]` means that the most recent value has a weight of `0.5`, and the second most recent value has a weight of `0.3`. Realistically, the second most recent value will have less influence than the most recent value, and will therefore have a lower value (closer to `#!py 0`), but it can still affect the current value.\n\n        **The `#!py MA` (Moving Average) Parameter:**\n\n        - The MA parameter is a list of coefficients that determine how much past random shocks (errors) influence the current value.\n        - For example, with `#!py MA=[0.2, 0.1]`:\n            - The value at time `#!py t` is influenced by:\n            - 20% of the random shock at time `#!py t-1`\n            - 10% of the random shock at time `#!py t-2`\n        - This creates short-term corrections or adjustments based on recent random fluctuations.\n        - Higher MA values (closer to `#!py 1`) create stronger corrections and more correlation with past shocks.\n        - When `#!py MA=[0]`, the time series is purely autoregressive, as it will depend on past values and does not depend on past shocks. Likewise, when `#!py MA=[1]`, the time series is purely random and will not depend on previous values.\n        - When multiple values are provided, the first value is the most recent, and the last value is the oldest. For example, `#!py MA=[0.5, 0.3]` means that the most recent value has a weight of `0.5`, and the second most recent value has a weight of `0.3`. Realistically, the second most recent value will have less influence than the most recent value, and will therefore have a lower value (closer to `#!py 0`), but it can still affect the current value.\n\n        **Examples and Effects:**\n\n        | Value                                | Description |\n        |--------------------------------------|-------------|\n        | `#!py AR=[0.9]`                      | Creates strong persistence - values strongly follow the previous value, resulting in smooth, trending data |\n        | `#!py AR=[0.5,0.3]`                  | Creates moderate persistence with some oscillation patterns |\n        | `#!py MA=[0.8]`                      | Creates immediate corrections after random shocks |\n        | `#!py MA=[0.5,0.3]`                  | Creates moderate corrections with some oscillation patterns |\n        | `#!py AR=[0.7]` &lt;br&gt; `#!py MA=[0.4]` | Combines trend persistence with short-term corrections |\n    \"\"\"\n\n    # Validations\n    AR = AR or [1]\n    MA = MA or [0]\n    exogenous = exogenous or []\n    assert exogenous is not None\n    self._assert_all_values_are_between(AR, min_value=0, max_value=1)\n    self._assert_all_values_are_between(MA, min_value=0, max_value=1)\n\n    # Noise\n    u: NDArray[np.float64] = self._random_generator(seed=seed).normal(\n        loc=0.0,\n        scale=randomwalk_scale,\n        size=n_periods,\n    )\n    ts: NDArray[np.float64] = np.zeros(n_periods).astype(np.float64)\n    for i in range(n_periods):\n        for i_ar in range(min(len(AR), i)):\n            ts[i] = ts[i] + AR[i_ar] * ts[i - 1 - i_ar]\n        ts[i] = ts[i] + u[i]\n        for i_ma in range(min(len(MA), i)):\n            ts[i] = ts[i] - MA[i_ma] * u[i - 1 - i_ma]\n        for exvar in exogenous:\n            for i_ar in range(len(exvar[\"coeff\"])):\n                ts[i] = ts[i] + exvar[\"coeff\"][i_ar] * exvar[\"ts\"][i - i_ar]\n    return ts\n</code></pre>"},{"location":"usage/overview/","title":"Overview<code>synthetic-data-generators</code>","text":""},{"location":"usage/overview/#introduction","title":"Introduction","text":"<p>The purpose of this package is to provide  a set of tools for generating synthetic data for various use cases. The package includes a variety of data generators, including random number generators, text generators, image generators, and time series generators. The package is designed to be easy to use and flexible, allowing users to customize the generated data to meet their specific needs.</p>"},{"location":"usage/overview/#key-urls","title":"Key URLs","text":"<p>For reference, these URL's are used:</p> Type Source URL Git Repo GitHub https://github.com/data-science-extensions/synthetic-data-generators Python Package PyPI https://pypi.org/project/synthetic-data-generators Package Docs Pages https://data-science-extensions.com/synthetic-data-generators/"},{"location":"usage/overview/#installation","title":"Installation","text":"<p>You can install and use this package multiple ways by using <code>pip</code>, <code>pipenv</code>, or <code>poetry</code>.</p>"},{"location":"usage/overview/#using-pip","title":"Using <code>pip</code>:","text":"<ol> <li> <p>In your terminal, run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install synthetic-data-generators\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>synthetic-data-generators\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install --requirement=requirements.txt\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-pipenv","title":"Using <code>pipenv</code>:","text":"<ol> <li> <p>Install using environment variables:</p> <p>In your <code>Pipfile</code> file, add:</p> <pre><code>[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = false\nname = \"pypi\"\n\n[packages]\nsynthetic-data-generators = \"*\"\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install pipenv\npython3 -m pipenv install --verbose --skip-lock --categories=root index=pypi synthetic-data-generators\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>synthetic-data-generators\n</code></pre> <p>Then run:</p> <pre><code>python3 -m run pipenv install --verbose --skip-lock --requirements=requirements.txt\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>python3 -m pipenv install --verbose --skip-lock synthetic-data-generators\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-poetry","title":"Using <code>poetry</code>:","text":"<ol> <li> <p>In your <code>pyproject.toml</code> file, add:</p> <pre><code>[project]\ndependencies = [\n    synthetic-data-generators = \"*\",\n]\n</code></pre> <p>Then run:</p> <pre><code>poetry install\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>poetry add synthetic-data-generators\npoetry install\npoetry sync\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-uv","title":"Using <code>uv</code>:","text":"<ol> <li> <p>In your <code>pyproject.toml</code> file, add:</p> <pre><code>[project]\ndependencies = [\n    synthetic-data-generators = \"*\",\n]\n</code></pre> <p>Then run:</p> <pre><code>uv sync\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>uv add synthetic-data-generators\nuv sync\n</code></pre> </li> </ol>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>Contribution is always welcome.</p> <ol> <li> <p>First, either fork or branch the main repo.</p> </li> <li> <p>Clone your forked/branched repo.</p> </li> <li> <p>Build your environment:</p> <ol> <li> <p>With <code>pipenv</code> on Windows:</p> <pre><code>if (-not (Test-Path .venv)) {mkdir .venv}\npython -m pipenv install --requirements requirements.txt --requirements requirements-dev.txt --skip-lock\npython -m poetry run pre-commit install\npython -m poetry run pre-commit autoupdate\npython -m poetry shell\n</code></pre> </li> <li> <p>With <code>pipenv</code> on Linux:</p> <pre><code>mkdir .venv\npython3 -m pipenv install --requirements requirements.txt --requirements requirements-dev.txt --skip-lock\npython3 -m poetry run pre-commit install\npython3 -m poetry run pre-commit autoupdate\npython3 -m poetry shell\n</code></pre> </li> <li> <p>With <code>poetry</code> on Windows:</p> <pre><code>python -m pip install --upgrade pip\npython -m pip install poetry\npython -m poetry config virtualenvs.create true\npython -m poetry config virtualenvs.in-project true\npython -m poetry init\npython -m poetry lock\npython -m poetry install --no-interaction --with dev,docs,test\npython -m poetry run pre-commit install\npython -m poetry run pre-commit autoupdate\npython -m poetry shell\n</code></pre> </li> <li> <p>With <code>poetry</code> on Linux:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install poetry\npython3 -m poetry config virtualenvs.create true\npython3 -m poetry config virtualenvs.in-project true\npython3 -m poetry init\npython3 -m poetry lock\npython3 -m poetry install --no-interaction --with dev,docs,test\npython3 -m poetry run pre-commit install\npython3 -m poetry run pre-commit autoupdate\npython3 -m poetry shell\n</code></pre> </li> <li> <p>With <code>uv</code> on Windows:</p> <pre><code>python -m pip install --upgrade pip\npython -m pip install uv\npython -m uv sync\npython -m uv run pre-commit install\npython -m uv run pre-commit autoupdate\n</code></pre> </li> <li> <p>With <code>uv</code> on Linux:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install uv\npython3 -m uv sync\npython3 -m uv run pre-commit install\npython3 -m uv run pre-commit autoupdate\n</code></pre> </li> </ol> </li> <li> <p>Start contributing.</p> </li> <li> <p>When you're happy with the changes, raise a Pull Request to merge with the main branch again.</p> </li> </ol>"},{"location":"usage/overview/#build-and-test","title":"Build and Test","text":"<p>To ensure that the package is working as expected, please ensure that:</p> <ol> <li>You write your code as per PEP8 requirements.</li> <li>You write a UnitTest for each function/feature you include.</li> <li>The CodeCoverage is 100%.</li> <li>All UnitTests are passing.</li> <li>MyPy is passing 100%.</li> </ol>"},{"location":"usage/overview/#testing","title":"Testing","text":"<ul> <li> <p>Run them all together</p> <pre><code>uv run make check\n</code></pre> </li> <li> <p>Or run them individually:</p> <ul> <li> <p>Black <pre><code>uv run make check-black\n</code></pre></p> </li> <li> <p>PyTests:     <pre><code>uv run make ckeck-pytest\n</code></pre></p> </li> <li> <p>MyPy:     <pre><code>uv run make check-mypy\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"usage/time_series/","title":"Time Series Generators","text":"<p>All of the examples in this page are using the <code>TimeSeriesGenerator().create_time_series()</code> method.</p>"},{"location":"usage/time_series/#straight-line","title":"Straight Line","text":"<p>We get a straight line by having a specific few interpolation nodes:</p> <ul> <li><code>interpolation_nodes=[[n_periods * i / 4, 100 * i] for i in range(4)]</code></li> </ul> <p>And when setting the parameters:</p> <ul> <li><code>randomwalk_scale=0</code></li> <li><code>noise_scale=0</code></li> <li><code>season_eff=0</code></li> </ul> Expand for full code snippet Linear trend: With straight line<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=[[n_periods * i / 4, 100 * i] for i in range(4)],  # (1)\n    level_breaks=[],\n    man_outliers=[],\n    AR=[],\n    MA=[],\n    exogenous=[],\n    randomwalk_scale=0,  # (2)\n    noise_scale=0,  # (3)\n    season_eff=0,  # (4)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"Straight line with no noise\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_straight_line.html\")\nfig.show()\n</code></pre> <ol> <li>Straight line interpolation</li> <li>No random walks</li> <li>No noise</li> <li>No seasonality</li> </ol>"},{"location":"usage/time_series/#smooth-curve","title":"Smooth Curve","text":"<p>If the interpolation nodes were more randomised (not in a straight line), then the generator will aim to build a smooth line which passes through each interpolation node.</p> <p>For example, if you specify the nodes as:</p> <ul> <li><code>interpolation_nodes=[(0.0, 0), (274.0, 400), (548.0, 250), (822.0, 50)]</code></li> </ul> <p>Then you will get a curve that looks like:</p> Expand for full code snippet Linear trend: With random interpolation nodes<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=list(\n        zip([n_periods * i / 4 for i in range(4)], [0, 400, 250, 50])\n    ),  # (1)\n    level_breaks=[],\n    manual_outliers=[],\n    AR=[],\n    MA=[],\n    exogenous=[],\n    randomwalk_scale=0,  # (2)\n    noise_scale=0,  # (3)\n    season_eff=0,  # (4)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"Smooth curve with no noise\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"./images/linear_smooth_curve.html\")\nfig.show()\n</code></pre> <ol> <li>Randomised interpolation</li> <li>No random walks</li> <li>No noise</li> <li>No seasonality</li> </ol>"},{"location":"usage/time_series/#noise","title":"Noise","text":"<p>The noise is just shifting the data points around  a amount of normal distribution along the linear trend line, with the scale being the standard deviation.</p> <p>It is controlled with the parameter:</p> <ul> <li><code>noise_scale=10</code></li> </ul> Expand for full code snippet Linear trend: With no noise<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[n_periods * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    manual_outliers=[],\n    AR=[],\n    MA=[],\n    exogenous=[],\n    randomwalk_scale=0,  # (1)\n    noise_scale=10,  # (2)\n    season_eff=0,  # (3)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"Straight line with noise\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_noise.html\")\nfig.show()\n</code></pre> <ol> <li>No random walks</li> <li>A little bit of noise</li> <li>No seasonality</li> </ol> <p>If we increase the <code>noise_scale</code>, then that will widen the standard deviation of the normal distribution, and add more noise.</p> Expand for full code snippet Linear trend: With no noise<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[n_periods * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    manual_outliers=[],\n    AR=[],\n    MA=[],\n    exogenous=[],\n    randomwalk_scale=0,  # (1)\n    noise_scale=50,  # (2)\n    season_eff=0,  # (3)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"Straight line with more noise\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_more_noise.html\")\nfig.show()\n</code></pre> <ol> <li>No random walks</li> <li>A lot of of noise</li> <li>No seasonality</li> </ol>"},{"location":"usage/time_series/#randomwalk","title":"Randomwalk","text":"<p>The random walk is a random process that describes a path consisting of a succession of random steps. It utilises a randomisation parameter around the normal distribution, then adds the value to the previous one using the Autoregressive (AR) and Moving Average (MA) models (see the ARMA for more mathematical detail).</p> <p>It is controlled with the <code>randomwalk_scale</code> parameter. Similar to the <code>manual_outliers</code> parameter, this affects the standard deviation of the normal distribution used to generate the random walk:</p> <ul> <li><code>randomwalk_scale=10</code></li> </ul> Expand for full code snippet Linear trend: With randomwalk<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[n_periods * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    manual_outliers=[],\n    AR=[],\n    MA=[],\n    exogenous=[],\n    randomwalk_scale=3,  # (1)\n    noise_scale=0,  # (2)\n    season_eff=0,  # (3)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"With noise\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_randomwalk.html\")\nfig.show()\n</code></pre> <ol> <li>A little bit of random walk</li> <li>No noise</li> <li>No seasonality</li> </ol> <p>If you increase this scale, it will increase the standard deviation of each progressive step, introducing more randomisation.</p> Expand for full code snippet Linear trend: With no more randomwalk<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[n_periods * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    manual_outliers=[],\n    AR=[],\n    MA=[],\n    exogenous=[],\n    randomwalk_scale=7,  # (1)\n    noise_scale=0,  # (2)\n    season_eff=0,  # (3)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"With more randomwalk\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_more_randomwalk.html\")\nfig.show()\n</code></pre> <ol> <li>A lot more of random walk</li> <li>No noise</li> <li>No seasonality</li> </ol> <p>The random walk can also be used in conjunction with the AR and MA models. For example, if you set the <code>AR=[0.9]</code>, then you will get a time series that is a combination of a random walk and an autoregressive process. To read more about the <code>AR</code> parameter, check the docs for the <code>generate_ARMA()</code> method.</p> Expand for full code snippet Linear trend: With no more randomwalk<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[n_periods * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    manual_outliers=[],\n    AR=[0.9],  # (1)\n    MA=[0],  # (2)\n    exogenous=[],\n    randomwalk_scale=7,  # (3)\n    noise_scale=0,  # (4)\n    season_eff=0,  # (5)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"With randomwalk and AR[0.9]\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_randomwalk_and_ar.html\")\nfig.show()\n</code></pre> <ol> <li>Auto Regression: Each element is affected 90% by the previous value</li> <li>Moving Average: There is no Moving Average effect</li> <li>A large random walk affect</li> <li>No noise</li> <li>No seasonality</li> </ol> <p>If you set the <code>MA=[0.4]</code>, then you will get a time series that is a combination of a random walk and a moving average process. To read more about the <code>MA</code> parameter, check the docs for the <code>generate_ARMA()</code> method.</p> Expand for full code snippet Linear trend: With no more randomwalk<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[n_periods * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=n_periods,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    manual_outliers=[],\n    AR=[1],\n    MA=[0.4],\n    exogenous=[],\n    randomwalk_scale=7,  # (1)\n    noise_scale=0,  # (2)\n    season_eff=0,  # (3)\n    season_conf=None,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"With randomwalk and MA[0.4]\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_randomwalk_and_ma.html\")\nfig.show()\n</code></pre> <ol> <li>Auto Regression: There is no Auto Regressive effect</li> <li>Moving Average: Each value is corrected by 40% from the random walk effect</li> <li>A large random walk affect</li> <li>No noise</li> <li>No seasonality</li> </ol>"},{"location":"usage/time_series/#seasonality","title":"Seasonality","text":"<p>The seasonality is a periodic fluctuation in the data, which can be controlled with the <code>season_eff</code> parameter. This parameter is then controlled with the <code>season_conf</code> parameter, which a dictionary with the following keys:</p> <ul> <li><code>style</code>: The style of the seasonality. One of:<ul> <li><code>fixed+error</code>: A fixed error pattern.</li> <li><code>semi-markov</code>: A semi-Markov pattern.</li> <li><code>holiday</code>: A fixed list of holiday dates.</li> <li><code>sin</code>: A sine wave pattern.</li> <li><code>sin_covar</code>: A sine wave covariance pattern.</li> </ul> </li> <li><code>season_dates</code>: A list of dates for the seasonality. This is only used if <code>style</code> is <code>holiday</code>.</li> <li><code>period_length</code>: The length of the period for the seasonality. For example, if the frequency is weekly, this would be <code>7</code>. This is only used if <code>style</code> is <code>sin</code> or <code>sin_covar</code>.</li> <li><code>period_sd</code>: The standard deviation of the period for the seasonality. This is only used if <code>style</code> is <code>sin</code> or <code>sin_covar</code>.</li> <li><code>start_index</code>: The starting index for the seasonality. This is only used if <code>style</code> is <code>sin</code> or <code>sin_covar</code>.</li> </ul> <p>For example, if you set the <code>season_conf</code> parameter to:</p> <pre><code>season_conf = {\n    \"style\": \"sin\",\n    \"period_length\": 365,\n    \"start_index\": 0,\n}\n</code></pre> <p>Then you will get a sine wave pattern with a period of <code>365</code> days and a starting index of <code>0</code>. The amplitude is the maximum value of the sine wave, which is <code>0.5</code> in this case.</p> Expand for full code snippet Linear trend: With no noise<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[1096 * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=1096,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    AR=[],\n    MA=[],\n    randomwalk_scale=0,\n    exogenous=[],\n    season_eff=0.5,  # (1)\n    season_conf={\"style\": \"sin\", \"period_length\": 365, \"start_index\": 0},  # (2)\n    manual_outliers=[],\n    noise_scale=0,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"With yearly seasonality (sine wave)\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_yearly_seasonality.html\")\nfig.show()\n</code></pre> <ol> <li>Add seasonality effect of <code>0.5</code></li> <li>Use Sine wave, with a wavelength of 365</li> </ol> <p>Another example with a different period length and starting index:</p> <pre><code>season_conf = {\n    \"style\": \"sin\",\n    \"period_length\": 30,\n    \"start_index\": 4,\n}\n</code></pre> <p>Then you will get a sine wave pattern with a period of <code>30</code> days (approximate monthly seasonality) and a starting index of <code>4</code>. The amplitude is the maximum value of the sine wave, which is <code>0.5</code> in this case.</p> Expand for full code snippet Linear trend: With no noise<pre><code># Imports\nimport pandas as pd\nfrom plotly import express as px, io as pio, graph_objects as go\nfrom synthetic_data_generators.time_series import TimeSeriesGenerator\n\n# Settings\npio.templates.default = \"simple_white+gridon\"\nSEED = 42\nTSG = TimeSeriesGenerator()\nn_periods = 1096\n\n# Create data\ninterpolation_nodes = [[1096 * i / 4, 100 * i] for i in range(4)]\ndf: pd.DataFrame = TSG.create_time_series(\n    start_date=datetime(2019, 1, 1),\n    n_periods=1096,\n    interpolation_nodes=interpolation_nodes,\n    level_breaks=[],\n    AR=[],\n    MA=[],\n    randomwalk_scale=0,\n    exogenous=[],\n    season_eff=0.5,  # (1)\n    season_conf={\"style\": \"sin\", \"period_length\": 30, \"start_index\": 0},  # (2)\n    manual_outliers=[],\n    noise_scale=0,\n    seed=SEED,\n)\n\n# Build plot\nfig: go.Figure = px.line(\n    df,\n    x=\"Date\",\n    y=\"Value\",\n    title=\"Linear Trend\",\n    subtitle=\"With (approximate) monthly seasonality (sine wave)\",\n).update_layout(title_x=0.5, title_xanchor=\"center\")\n\n# Render plot\nfig.write_html(\"images/linear_with_monthly_seasonality.html\")\nfig.show()\n</code></pre> <ol> <li>Add seasonality effect of <code>0.5</code></li> <li>Use Sine wave, with a wavelength of 30</li> </ol>"}]}